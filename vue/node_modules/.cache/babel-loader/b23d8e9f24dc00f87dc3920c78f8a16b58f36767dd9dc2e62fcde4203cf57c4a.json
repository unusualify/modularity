{"ast":null,"code":"import { mapState } from 'vuex';\nimport { MEDIA_LIBRARY } from '@/store/mutations';\nimport api from '../../store/api/media-library';\nimport ACTIONS from '@/store/actions';\nimport UEModal from './Modal.vue';\nimport scrollToY from '@/utils/scrollToY.js';\nimport FormDataAsObj from '@/utils/formDataAsObj.js';\nimport { ModalMixin } from '@/mixins';\nexport default {\n  mixins: [ModalMixin],\n  components: {\n    'ue-modal': UEModal\n  },\n  props: {\n    modalTitlePrefix: {\n      type: String,\n      default: function () {\n        return this.$trans('media-library.title', 'Media Library');\n      }\n    },\n    btnLabelSingle: {\n      type: String,\n      default: function () {\n        return this.$trans('media-library.insert', 'Insert');\n      }\n    },\n    btnLabelUpdate: {\n      type: String,\n      default: function () {\n        return this.$trans('media-library.update', 'Update');\n      }\n    },\n    btnLabelMulti: {\n      type: String,\n      default: function () {\n        return this.$trans('media-library.insert', 'Insert');\n      }\n    },\n    initialPage: {\n      type: Number,\n      default: 1\n    },\n    authorized: {\n      type: Boolean,\n      default: true\n    },\n    showInsert: {\n      type: Boolean,\n      default: true\n    },\n    extraMetadatas: {\n      type: Array,\n      default() {\n        return [];\n      }\n    },\n    translatableMetadatas: {\n      type: Array,\n      default() {\n        return [];\n      }\n    }\n  },\n  data: function () {\n    return {\n      loading: false,\n      maxPage: 20,\n      mediaItems: [],\n      selectedMedias: [],\n      gridHeight: 0,\n      page: this.initialPage,\n      tags: [],\n      lastScrollTop: 0,\n      gridLoaded: false,\n      full: true,\n      show: true\n    };\n  },\n  computed: {\n    renderedMediaItems: function () {\n      return this.mediaItems.map(item => {\n        item.disabled = this.filesizeMax > 0 && item.filesizeInMb > this.filesizeMax || this.widthMin > 0 && item.width < this.widthMin || this.heightMin > 0 && item.height < this.heightMin;\n        return item;\n      });\n    },\n    currentTypeObject: function () {\n      return this.types.find(type => {\n        return type.value === this.type;\n      });\n    },\n    endpoint: function () {\n      return this.currentTypeObject.endpoint;\n    },\n    modalTitle: function () {\n      if (this.connector) {\n        if (this.indexToReplace > -1) return this.modalTitlePrefix + ' – ' + this.btnLabelUpdate;\n        return this.selectedMedias.length > 1 ? this.modalTitlePrefix + ' – ' + this.btnLabelMulti : this.modalTitlePrefix + ' – ' + this.btnLabelSingle;\n      }\n      return this.modalTitlePrefix;\n    },\n    btnLabel: function () {\n      let type = this.$trans('media-library.types.single.' + this.type, this.type);\n      if (this.indexToReplace > -1) {\n        return this.btnLabelUpdate + ' ' + type;\n      } else {\n        if (this.selectedMedias.length > 1) {\n          type = this.$trans('media-library.types.multiple.' + this.type, this.type);\n        }\n        return this.btnLabelSingle + ' ' + type;\n      }\n    },\n    usedMedias: function () {\n      return this.selected[this.connector] || [];\n    },\n    selectedType: function () {\n      const self = this;\n      const navItem = self.types.filter(function (t) {\n        return t.value === self.type;\n      });\n      return navItem[0];\n    },\n    canInsert: function () {\n      return !this.selectedMedias.some(sMedia => !!this.usedMedias.find(uMedia => uMedia.id === sMedia.id));\n    },\n    ...mapState({\n      connector: state => state.mediaLibrary.connector,\n      max: state => state.mediaLibrary.max,\n      filesizeMax: state => state.mediaLibrary.filesizeMax,\n      widthMin: state => state.mediaLibrary.widthMin,\n      heightMin: state => state.mediaLibrary.heightMin,\n      type: state => state.mediaLibrary.type,\n      // image, video, file\n      types: state => state.mediaLibrary.types,\n      strict: state => state.mediaLibrary.strict,\n      selected: state => state.mediaLibrary.selected,\n      indexToReplace: state => state.mediaLibrary.indexToReplace\n\n      // showModal: state => state.mediaLibrary.showModal,\n\n      // show: state => state.mediaLibrary.showModal,\n    })\n\n    // show: {\n    //     get () {\n    //         return this.$store.state.mediaLibrary.showModal;\n    //     },\n    //     set (value) {\n    //         // this.$store.dispatch(ACTIONS.TOGGLE_MEDIA_MODAL, value)\n    //     }\n    // },\n  },\n\n  watch: {\n    type: function () {\n      this.clearMediaItems();\n      this.gridLoaded = false;\n    }\n  },\n  methods: {\n    // for ue-uploader\n    addMedia: function (media) {\n      const index = this.mediaItems.findIndex(function (item) {\n        return item.id === media.id;\n      });\n\n      // Check of the media item exists i.e replacement\n      if (index > -1) {\n        for (const mediaRole in this.selected) {\n          this.selected[mediaRole].forEach((mediaCrop, index) => {\n            if (media.id === mediaCrop.id) {\n              const crops = [];\n              for (const crop in mediaCrop.crops) {\n                crops[crop] = {\n                  height: media.height === mediaCrop.height ? mediaCrop.crops[crop].height : media.height,\n                  name: crop,\n                  width: media.width === mediaCrop.width ? mediaCrop.crops[crop].width : media.width,\n                  x: media.width === mediaCrop.width ? mediaCrop.crops[crop].x : 0,\n                  y: media.height === mediaCrop.height ? mediaCrop.crops[crop].y : 0\n                };\n              }\n              this.$store.commit(MEDIA_LIBRARY.UPDATE_MEDIAS, {\n                index,\n                media: {\n                  ...media,\n                  width: media.width === mediaCrop.width ? mediaCrop.width : media.width,\n                  height: media.height === mediaCrop.height ? mediaCrop.height : media.height,\n                  crops\n                },\n                mediaRole\n              });\n            }\n          });\n        }\n        this.$set(this.mediaItems, index, media);\n        this.selectedMedias.unshift(media);\n      } else {\n        // add media in first position of the available media\n        this.mediaItems.unshift(media);\n        this.$store.commit(MEDIA_LIBRARY.INCREMENT_MEDIA_TYPE_TOTAL, this.type);\n        // select it\n        this.updateSelectedMedias(media.id);\n      }\n    },\n    updateSelectedMedias: function (item, shift = false) {\n      const id = item.id;\n      const alreadySelectedMedia = this.selectedMedias.filter(function (media) {\n        return media.id === id;\n      });\n\n      // not already selected\n      if (alreadySelectedMedia.length === 0) {\n        if (this.max === 1) this.clearSelectedMedias();\n        if (this.selectedMedias.length >= this.max && this.max > 0) return;\n        if (shift && this.selectedMedias.length > 0) {\n          const lastSelectedMedia = this.selectedMedias[this.selectedMedias.length - 1];\n          const lastSelectedMediaIndex = this.mediaItems.findIndex(media => media.id === lastSelectedMedia.id);\n          const selectedMediaIndex = this.mediaItems.findIndex(media => media.id === id);\n          if (selectedMediaIndex === -1 && lastSelectedMediaIndex === -1) return;\n          let start = null;\n          let end = null;\n          if (lastSelectedMediaIndex < selectedMediaIndex) {\n            start = lastSelectedMediaIndex + 1;\n            end = selectedMediaIndex + 1;\n          } else {\n            start = selectedMediaIndex;\n            end = lastSelectedMediaIndex;\n          }\n          const selectedMedias = this.mediaItems.slice(start, end);\n          selectedMedias.forEach(media => {\n            if (this.selectedMedias.length >= this.max && this.max > 0) return;\n            const index = this.selectedMedias.findIndex(m => m.id === media.id);\n            if (index === -1) {\n              this.selectedMedias.push(media);\n            }\n          });\n        } else {\n          const mediaToSelect = this.mediaItems.filter(function (media) {\n            return media.id === id;\n          });\n\n          // Add one media to the selected media\n          if (mediaToSelect.length) this.selectedMedias.push(mediaToSelect[0]);\n        }\n      } else {\n        // Remove one item from the selected media\n        this.selectedMedias = this.selectedMedias.filter(function (media) {\n          return media.id !== id;\n        });\n      }\n    },\n    clearSelectedMedias: function () {\n      this.selectedMedias.splice(0);\n    },\n    // for ue-filter\n    clearFilters: function () {\n      const self = this;\n      // reset tags\n      if (this.$refs.filter) this.$refs.filter.value = null;\n      // reset unused field\n      if (this.$refs.unused) {\n        const input = this.$refs.unused.$el.querySelector('input');\n        input && input.checked && input.click();\n      }\n      this.$nextTick(function () {\n        self.submitFilter();\n      });\n    },\n    submitFilter: function (formData) {\n      const self = this;\n      const el = this.$refs.list;\n      // when changing filters, reset the page to 1\n      this.page = 1;\n      this.clearMediaItems();\n      this.clearSelectedMedias();\n      if (el.scrollTop === 0) {\n        self.reloadGrid();\n        return;\n      }\n      scrollToY({\n        el: el,\n        offset: 0,\n        easing: 'easeOut',\n        onComplete: function () {\n          self.reloadGrid();\n        }\n      });\n    },\n    clearMediaItems: function () {\n      this.mediaItems.splice(0);\n    },\n    clearSelectedMedias: function () {\n      this.selectedMedias.splice(0);\n    },\n    reloadGrid: function () {\n      this.loading = true;\n      const form = this.$refs.form;\n      const formdata = this.getFormData(form);\n\n      // if (this.selected[this.connector]) {\n      //   formdata.except = this.selected[this.connector].map((media) => {\n      //     return media.id\n      //   })\n      //   console.log(formdata.except)\n      // }\n\n      // see api/media-library for actual ajax\n      api.get(this.endpoint, formdata, resp => {\n        // add medias here\n        resp.data.items.forEach(item => {\n          if (!this.mediaItems.find(media => media.id === item.id)) {\n            this.mediaItems.push(item);\n          }\n        });\n        this.maxPage = resp.data.maxPage || 1;\n        this.tags = resp.data.tags || [];\n        this.$store.commit(MEDIA_LIBRARY.UPDATE_MEDIA_TYPE_TOTAL, {\n          type: this.type,\n          total: resp.data.total\n        });\n        this.loading = false;\n        this.listenScrollPosition();\n        this.gridLoaded = true;\n      }, error => {\n        // this.$store.commit(NOTIFICATION.SET_NOTIF, {\n        //   message: error.data.message,\n        //   variant: 'error'\n        // })\n      });\n    },\n    updateType: function (newType) {\n      if (this.loading) return;\n      if (this.strict) return;\n      if (this.type === newType) return;\n      this.$store.commit(MEDIA_LIBRARY.UPDATE_MEDIA_TYPE, newType);\n      this.submitFilter();\n    },\n    getFormData: function (form) {\n      let data = FormDataAsObj(form);\n      if (data) data.page = this.page;else data = {\n        page: this.page\n      };\n      data.type = this.type;\n      if (Array.isArray(data.unused) && data.unused.length) {\n        data.unused = data.unused[0];\n      }\n      return data;\n    }\n  },\n  created() {\n    // __log(this)\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}