{"ast":null,"code":"import _objectSpread from \"/var/www/crm_template/packages/oobook/crm-base/vue/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.string.starts-with.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.match.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.string.includes.js\";\nimport \"core-js/modules/es.regexp.test.js\";\nimport \"core-js/modules/es.array.is-array.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.regexp.constructor.js\";\nimport \"core-js/modules/es.regexp.dot-all.js\";\nimport \"core-js/modules/es.regexp.sticky.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.object.keys.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/es.array.for-each.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.array.push.js\";\n// Import\nimport Vue from 'vue';\nimport { get, isPlainObject, isFunction, isString, isNumber, isEmpty, orderBy, delay } from 'lodash';\n\n// import VueMask from 'v-mask'\n// Vue.use(VueMask, {\n//   placeholders: {\n//     // Info Mask https://github.com/probil/v-mask\n//     // '#': null,       // passing `null` removes default placeholder, so `#` is treated as character\n//     // D: /\\d/,         // define new placeholder\n//   }\n// })\n//\n// Declaration\nvar typeToComponent = {\n  // maps schema.type to prop 'type' in v-text-field  - https://www.wufoo.com/html5/\n  text: 'v-text-field',\n  password: 'v-text-field',\n  email: 'v-text-field',\n  tel: 'v-text-field',\n  url: 'v-text-field',\n  search: 'v-text-field',\n  number: 'v-text-field',\n  /*\n        { type:'text, ext:'typeOfTextField', ...}\n        For native <INPUT> type use alternative schema prop ext  -> schema:{ type:'text, ext:'date', ...}\n        correspond to <input type=\"number\" >\n        number: 'v-text-field',   //  { type:'text, ext:'number', ...}\n        range: 'v-text-field',   //  { type:'text, ext:'range', ...}\n        date: 'v-text-field',    //  { type:'text, ext:'date', ...}\n        time: 'v-text-field',    //  { type:'text, ext:'time', ...}\n        color: 'v-text-field',   //  { type:'text, ext:'color', ...}\n      */\n\n  date: 'v-date-picker',\n  time: 'v-time-picker',\n  color: 'v-color-picker',\n  /*\n        INFO: 3 Types of PICKER DATE / TIME / COLOR\n        Date-Native Input    - schema:{ type:'text, ext:'date', ...}\n        Date-Picker          - schema:{ type:'date', ...}\n        Date-Picker-Textmenu     - schema:{ type:'date', ext:'text'...}\n      */\n\n  // map schema.type to vuetify-control (vuetify 2.0)\n  img: 'v-img',\n  textarea: 'v-textarea',\n  range: 'v-slider',\n  file: 'v-file-input',\n  \"switch\": 'v-switch',\n  checkbox: 'v-checkbox',\n  card: 'v-card'\n  /*\n        HOW TO USE CUSTOM Components\n        1)\n          Name and Register your Custom-Control Component globally in 'main.js'\n          but avoid collision with registered names of Vuetify - Controls\n          See: https://vuejs.org/v2/guide/components-registration.html\n           Vue.component('custom-component', () => import('@/components/custom-component.vue') )\n         2)\n          use it in Schema\n           mySchema: { myCustom: { type: 'custom-component' }\n         3) // custom-component.vue\n          <template>\n            <v-text-field v-model=\"inp\"  label=\"Basic\"></v-text-field>\n          </template>\n          <script>\n            export default {\n              props: ['type','value', 'obj'],\n              computed:{\n                inp:{\n                  get(){  return this.value},\n                  set(v){ this.$emit('input', v)}\n                }\n              }\n            }\n          < /script>\n      */\n};\n\nvar orderDirection = 'ASC';\nvar pathDelimiter = '.';\nvar classKeyDelimiter = '-';\nvar defaultID = 'form-base';\nvar isPicker = 'date|time|color';\nvar onEventDelay = 1; // ms\n\nvar mouse = 'mouseenter|mouseleave';\nvar change = 'input|click'; // event change collects events 'input|click'\nvar watch = 'focus|input|click|blur'; // event watch collects events 'focus|input|click|blur'\nvar display = 'resize|swipe|intersect'; // event watch collects events 'resize|swipe|intersect'\n\nvar topAppendix = 'top';\nvar bottomAppendix = 'bottom';\nvar slotAppendix = 'slot';\nvar tooltipAppendix = 'tooltip';\nvar injectAppendix = 'inject';\nvar itemClassAppendix = 'item';\nvar typeClassAppendix = 'type';\nvar keyClassAppendix = 'key';\nvar arrayClassAppendix = 'array';\nvar propertyClassAppendix = 'prop';\nvar injectSlotAppendix = \"\".concat(slotAppendix, \"-\").concat(injectAppendix);\nvar arraySlotAppendix = \"\".concat(slotAppendix, \"-\").concat(arrayClassAppendix);\nvar topSlotAppendix = \"\".concat(slotAppendix, \"-\").concat(topAppendix);\nvar itemSlotAppendix = \"\".concat(slotAppendix, \"-\").concat(itemClassAppendix);\nvar bottomSlotAppendix = \"\".concat(slotAppendix, \"-\").concat(bottomAppendix);\nvar tooltipSlotAppendix = \"\".concat(slotAppendix, \"-\").concat(tooltipAppendix);\nvar clear = 'clear';\nvar button = 'button';\nvar treeview = 'treeview';\nvar list = 'list';\nvar focus = 'focus';\nvar blur = 'blur';\nvar append = 'append';\nvar appendOuter = 'append-outer';\nvar prepend = 'prepend';\nvar prependInner = 'prepend-inner';\nvar hour = 'hour';\nvar minute = 'minute';\nvar second = 'second';\n\n// symbol on drop\nvar dropEffect = 'move'; // 'copy, link, move\n// Default row setting if no row-attribute defined\nvar rowDefault = {\n  noGutters: true\n}; // { noGutters:true, justify:'center', align:'center' }\n\n// Default col setting, overrideable by prop col or by schema.col definition\n// Default col setting, overrideable by prop flex or by schema.flex definition (flex is DEPRECATED use col instead)\nvar colDefault = {\n  cols: 'auto'\n}; // { cols:12, sm: 6, md:4, lg:3, xl:2}\n\n// Mapper for Autogeneration of Schema from Value\nvar defaultSchemaIfValueIsNullOrUndefined = function defaultSchemaIfValueIsNullOrUndefined(key) {\n  return {\n    type: 'text',\n    label: key\n  };\n};\nvar defaultSchemaIfValueIsString = function defaultSchemaIfValueIsString(key) {\n  return {\n    type: 'text',\n    label: key\n  };\n};\nvar defaultSchemaIfValueIsNumber = function defaultSchemaIfValueIsNumber(key) {\n  return {\n    type: 'number',\n    label: key\n  };\n};\nvar defaultSchemaIfValueIsBoolean = function defaultSchemaIfValueIsBoolean(key) {\n  return {\n    type: 'checkbox',\n    label: key\n  };\n};\n// Menu triggered DateTimePicker Default\nvar defaultPickerSchemaText = {\n  type: 'text',\n  readonly: true\n};\nvar defaultPickerSchemaMenu = {\n  closeOnContentClick: false,\n  transition: 'scale-transition',\n  nudgeRight: 32,\n  maxWidth: '290px',\n  minWidth: '290px'\n};\n// type wrap or group - if no typeInt defined take default\nvar defaultInternGroupType = 'v-card';\n//\nexport default {\n  name: 'VFormBase',\n  props: {\n    id: {\n      type: String,\n      \"default\": defaultID\n    },\n    rootId: {\n      type: String,\n      \"default\": defaultID\n    },\n    row: {\n      type: [Object]\n    },\n    col: {\n      type: [Object, Number, String]\n    },\n    flex: {\n      type: [Object, Number, String]\n    },\n    value: {\n      type: [Object, Array],\n      \"default\": function _default() {\n        return null;\n      }\n    },\n    model: {\n      type: [Object, Array],\n      \"default\": function _default() {\n        return {};\n      }\n    },\n    schema: {\n      type: [Object, Array],\n      \"default\": function _default() {\n        return {};\n      }\n    }\n  },\n  data: function data() {\n    return {\n      flatCombinedArray: [],\n      clear: clear,\n      button: button,\n      treeview: treeview,\n      list: list,\n      focus: focus,\n      blur: blur,\n      append: append,\n      appendOuter: appendOuter,\n      prepend: prepend,\n      prependInner: prependInner,\n      hour: hour,\n      minute: minute,\n      second: second\n    };\n  },\n  computed: {\n    valueIntern: function valueIntern() {\n      // use <formbase :model=\"myData\" />  ->  legacy code <formbase :value=\"myData\" />\n      var model = this.model || this.value;\n      this.updateArrayFromState(model, this.schema);\n      return model;\n    },\n    parent: function parent() {\n      var p = this;\n      if (p.$parent && p.$parent.$parent) {\n        while (p.id.startsWith(p.$parent.$parent.id + '-')) {\n          p = p.$parent.$parent;\n        }\n      }\n      return p;\n    },\n    index: function index() {\n      var m = this.id && this.id.match(/\\d+/g);\n      return m ? m.map(Number) : null;\n    },\n    getRow: function getRow() {\n      return this.row || rowDefault;\n    },\n    flatCombinedArraySorted: function flatCombinedArraySorted() {\n      return orderBy(this.flatCombinedArray, ['schema.sort'], [orderDirection]);\n    },\n    storeStateData: function storeStateData() {\n      this.updateArrayFromState(this.valueIntern, this.schema);\n      return this.valueIntern;\n    },\n    storeStateSchema: function storeStateSchema() {\n      this.updateArrayFromState(this.valueIntern, this.schema);\n      return this.schema;\n    }\n  },\n  watch: {\n    schema: function schema(newSchema) {\n      this.rebuildArrays(this.valueIntern, newSchema);\n      this.schema = newSchema;\n    }\n  },\n  methods: {\n    // MAP TYPE\n    mapTypeToComponent: function mapTypeToComponent(type) {\n      // merge global registered components into typeToComponent Object\n      var allTypeComponents = _objectSpread(_objectSpread({}, typeToComponent), Vue.options.components);\n      // const typeToComponent -> maps type to according v-component\n      // ie. schema:{ type:'password', ... } to specific vuetify-control or default to v-text-field'\n      return allTypeComponents[type] ? allTypeComponents[type] : \"v-\".concat(type);\n    },\n    // CHECK FOR TYPE: DATE, TIME OR COLOR and EXT: TEXT\n    isDateTimeColorTypeAndExtensionText: function isDateTimeColorTypeAndExtensionText(obj) {\n      return isPicker.includes(obj.schema.type) && obj.schema.ext === 'text';\n    },\n    // CHECK FOR EXT: DATE, TIME OR COLOR\n    isDateTimeColorExtension: function isDateTimeColorExtension(obj) {\n      return isPicker.includes(obj.schema.ext);\n    },\n    // BIND SCHEMA TEXT OPTIONS\n    bindOptions: function bindOptions(b) {\n      // schema.options in RADIO/BUTTON\n      return isString(b) ? {\n        value: b,\n        label: b\n      } : b;\n    },\n    bindSchemaText: function bindSchemaText(obj) {\n      return _objectSpread(_objectSpread({}, defaultPickerSchemaText), obj.schema.text);\n    },\n    bindSchemaMenu: function bindSchemaMenu(obj) {\n      return _objectSpread(_objectSpread({}, defaultPickerSchemaMenu), obj.schema.menu);\n    },\n    bindSchema: function bindSchema(obj) {\n      return obj.schema;\n    },\n    suspendClickAppend: function suspendClickAppend(obj) {\n      // select|combobox|autocomplete -> suspend 'click:append' for working down arrow\n      return /(select|combobox|autocomplete)/.test(obj.schema.type) ? '' : 'click:append';\n    },\n    searchInputSync: function searchInputSync(obj) {\n      // schema.searchInput ->   bind 'search-input'\n      return typeof obj.schema.searchInput !== 'undefined' ? 'search-input' : '';\n    },\n    // EXT TYPE\n    checkExtensionType: function checkExtensionType(obj) {\n      // For native <INPUT> type use prop 'ext'\n      // { type:'text', ext:'range', ... } -> use native Input Type 'range' instead of slider\n      // { type:'text', ext:'number', ...} -> use native Input Type 'number'\n      return obj.schema.ext || obj.schema.type;\n    },\n    // V-INTERN TYPE\n    checkInternType: function checkInternType(obj) {\n      // If vuetify component needs a 'type' prop for working  - ie. datepicker uses type:'month'\n      // { type:'date', ext:'text', typeInt:'month' ...} -> use v-date-picker menu with intern Type 'month'\n      return obj.schema.typeInt || obj.schema.type;\n    },\n    checkInternGroupType: function checkInternGroupType(obj) {\n      //  in type 'wrap|group' you can define with typeInt: a component as group - schema: { group1: { type:'wrap', typeInt:'v-card', ... } ...}\n      var typeInt = obj.schema.typeInt || defaultInternGroupType;\n      return typeInt.startsWith('v-') ? typeInt : \"v-\".concat(typeInt);\n    },\n    // GET ITERATION KEY FOR TYPE ARRAY\n    getKeyForArray: function getKeyForArray(id, obj, item, index) {\n      // IMPORTANT if you want to add or remove items in type:'array'\n      // more Info ->\n      // https://forum.vuejs.org/t/after-splicing-an-object-wrong-item-disappears-from-view/9247/4\n      // https://stackoverflow.com/questions/45655090/vue-array-splice-removing-wrong-item-from-list\n\n      // create for iteration v-for an uniqe key from each object in array using index and time.hash\n      // or define your key index by defining a key property\n      // MODEL\n      // arrayTasks: [{ trace:'100', label:'A'}, ...  ]\n      // SCHEMA\n      // arrayTasks: { type:'array', schema:{ ... } }                                                      DEFAULT KEY -> KEY id-key-index   'arrayTasks-0'\n      // arrayTasks: { type:'array', key:'trace', schema:{ trace: { type:'text'}, ... } }                              -> KEY trace            100\n      // arrayTasks: { type:'array', key:['trace','label'], schema:{ trace: { type:'text'}, label: { type:'text'} } }  -> KEY trace_label      100_A\n\n      // IMPORTANT! Key should not contain an EDITABLE prop, because of re-iteration on any change\n\n      var k = obj.schema.key;\n      return k ? Array.isArray(k) ? k.map(function (i) {\n        return item[i];\n      }).join('_') : item[k] : !isNaN(index) ? \"\".concat(id, \"-\").concat(obj.key, \"-\").concat(index) : index;\n    },\n    //\n    // GET IMG SOURCE\n    getImageSource: function getImageSource(obj) {\n      // if exist get source from src otherwise join schema.base & value & schema.tail\n      return obj.schema.src ? obj.schema.src : \"\".concat(obj.schema.base).concat(obj.value).concat(obj.schema.tail);\n    },\n    //\n    // ICON\n    getIconValue: function getIconValue(obj) {\n      // icon: try schema.label or if undefined use value\n      return obj.schema.label ? obj.schema.label : this.setValue(obj);\n    },\n    //\n    // TOOLTIP\n    getShorthandTooltip: function getShorthandTooltip(schemaTooltip) {\n      // check if tooltip is typeof string ->  shorthand { bottom:true, label: obj.schema.tooltip} otherwise take original object\n      return isString(schemaTooltip) ? {\n        bottom: true,\n        label: schemaTooltip\n      } : schemaTooltip;\n    },\n    getShorthandTooltipLabel: function getShorthandTooltipLabel(schemaTooltip) {\n      // check if tooltip is typeof string ->  return Label\n      return isString(schemaTooltip) ? schemaTooltip : schemaTooltip && schemaTooltip.label;\n    },\n    //\n    // FORM SLOTS\n    getFormTopSlot: function getFormTopSlot() {\n      // Slot for Top Line in Formbase -> 'slot-formbase-top'\n      return \"\".concat(topSlotAppendix, \"-\").concat(this.id);\n    },\n    getFormBottomSlot: function getFormBottomSlot() {\n      // Slot for Bottom Line in Formbase -> 'slot-formbase-bottom'\n      return \"\".concat(bottomSlotAppendix, \"-\").concat(this.id);\n    },\n    //\n    // KEY SLOTS\n    getKeyInjectSlot: function getKeyInjectSlot(obj, inject) {\n      // get slot starting with 'slot-inject' and inject verb 'thumb-label'   -> 'slot-inject-thumb-label-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(injectSlotAppendix, \"-\").concat(inject, \"-\").concat(keyClassAppendix));\n    },\n    getKeyTopSlot: function getKeyTopSlot(obj) {\n      // get Key specific name by replacing '.' with '-' and prepending 'slot-top'  -> 'slot-top-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(topSlotAppendix, \"-\").concat(keyClassAppendix));\n    },\n    getKeyItemSlot: function getKeyItemSlot(obj) {\n      // get Key specific name by replacing '.' with '-' and prepending 'slot-item'  -> 'slot-item-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(itemSlotAppendix, \"-\").concat(keyClassAppendix));\n    },\n    getKeyBottomSlot: function getKeyBottomSlot(obj) {\n      // get Key specific name by replacing '.' with '-' and prepending 'slot-bottom'  -> 'slot-bottom-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(bottomSlotAppendix, \"-\").concat(keyClassAppendix));\n    },\n    getKeyTooltipSlot: function getKeyTooltipSlot(obj) {\n      // matches Key specific Tooltip | name by replacing '.' with '-' and prepending 'slot-bottom'  -> 'slot-tooltip-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(tooltipSlotAppendix, \"-\").concat(keyClassAppendix));\n    },\n    getTooltipSlot: function getTooltipSlot(obj) {\n      // default tooltip slot matches all keys\n      return \"\".concat(tooltipSlotAppendix);\n    },\n    //\n    // ARRAY SLOTS\n    getArrayTopSlot: function getArrayTopSlot(obj) {\n      // slot each item from array  -> 'slot-top-array-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(topSlotAppendix, \"-\").concat(arrayClassAppendix));\n    },\n    getArrayItemSlot: function getArrayItemSlot(obj) {\n      // slot each item from array  -> 'slot-top-array-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(itemSlotAppendix, \"-\").concat(arrayClassAppendix));\n    },\n    getArrayBottomSlot: function getArrayBottomSlot(obj) {\n      // slot each item from array   -> 'slot-bottom-array-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, \"\".concat(bottomSlotAppendix, \"-\").concat(arrayClassAppendix));\n    },\n    //\n    // TYPE SLOTS\n    getTypeTopSlot: function getTypeTopSlot(obj) {\n      // get Type specific slot name  -> 'slot-top-type-radio'\n      return this.getTypeClassNameWithAppendix(obj, \"\".concat(topSlotAppendix, \"-\").concat(typeClassAppendix));\n    },\n    getTypeItemSlot: function getTypeItemSlot(obj) {\n      // get Type specific slot name  -> 'slot-item-type-radio'\n      return this.getTypeClassNameWithAppendix(obj, \"\".concat(itemSlotAppendix, \"-\").concat(typeClassAppendix));\n    },\n    getTypeBottomSlot: function getTypeBottomSlot(obj) {\n      // get Type specific slot name  -> 'slot-bottom-type-radio'\n      return this.getTypeClassNameWithAppendix(obj, \"\".concat(bottomSlotAppendix, \"-\").concat(typeClassAppendix));\n    },\n    //\n    // CLASS Names\n    getPropertyClassNameWithAppendix: function getPropertyClassNameWithAppendix(obj, appendix) {\n      // get PROP specific name by app-/prepending 'appendix-' and replacing '.' with '-' in nested key path  -> 'controls switch'\n      return obj.key ? obj.key.split(pathDelimiter).map(function (s) {\n        return \"\".concat(appendix ? appendix + classKeyDelimiter : '').concat(s);\n      }).join(' ') : '';\n    },\n    getPropertyClassName: function getPropertyClassName(obj) {\n      return this.getPropertyClassNameWithAppendix(obj, propertyClassAppendix);\n    },\n    getKeyClassNameWithAppendix: function getKeyClassNameWithAppendix(obj, appendix) {\n      // get KEY specific name by app-/prepending 'appendix-' and replacing '.' with '-' in nested key path  -> 'top-slot-address-city'\n      return \"\".concat(appendix ? appendix + classKeyDelimiter : '').concat(this.id ? this.id + classKeyDelimiter : '').concat(obj.key.replace(/\\./g, '-'));\n      // return `${appendix ? appendix + classKeyDelimiter : ''}${obj.key.replace(/\\./g, '-')}`\n    },\n    getKeyClassName: function getKeyClassName(obj) {\n      return this.getKeyClassNameWithAppendix(obj, keyClassAppendix);\n    },\n    getTypeClassNameWithAppendix: function getTypeClassNameWithAppendix(obj, appendix) {\n      // get TYPE specific class name by prepending '-type' -> 'type-checkbox'\n      return \"\".concat(appendix ? appendix + classKeyDelimiter : '').concat(this.id ? this.id + classKeyDelimiter : '').concat(obj.schema.type);\n      // return `${appendix + classKeyDelimiter}${obj.schema.type}`\n    },\n    getTypeClassName: function getTypeClassName(obj) {\n      return this.getTypeClassNameWithAppendix(obj, typeClassAppendix);\n    },\n    getClassName: function getClassName(obj) {\n      // combines all into a single classname\n      // class => ie. 'item type-checkbox key-address-zip prop-adress prop-zip'\n      return \"\".concat(itemClassAppendix, \" \").concat(this.getTypeClassName(obj), \" \").concat(this.getKeyClassName(obj), \" \").concat(this.getPropertyClassName(obj));\n    },\n    //\n    // GRID\n    gridMapper: function gridMapper(obj, prepender) {\n      if (obj) {\n        ['sm', 'md', 'lg', 'xl'].map(function (k) {\n          if (obj[k]) {\n            obj[prepender + k] = obj[k];\n            delete obj[k];\n          }\n        });\n      }\n    },\n    gridReplaceXS: function gridReplaceXS(obj, replacer) {\n      // see vuetify Grid - replace Prop XS -V1.5 with COLS, ORDER, OFFSET - V2.0\n      // xs must be replaced in new Vuetify 2.0 Grid with cols, offset, order\n      if (obj && obj.xs) {\n        obj[replacer] = obj.xs;\n        delete obj.xs;\n      }\n    },\n    getGridAttributes: function getGridAttributes(obj) {\n      // FLEX DEPRECATED use COL instead of FLEX\n      // flex:{ xs|sm|md|lg } - value:number|string\n\n      // col:{ cols|sm|md|lg|xl } - value:number|string\n      // order:{ order|sm|md|lg|xl|order-sm|order-md|order-lg|order-xl } - value:number|string\n      // offset:{ offset|sm|md|lg|xl|offset-sm|offset-md|offset-lg|offset-xl } - value:number|string\n\n      var colSchema = obj.schema.col || obj.schema.flex;\n      var colAttr = this.col || this.flex || colDefault;\n      var colObject = colSchema\n      // if available use schema definition of cols\n      ? isPlainObject(colSchema) ? colSchema : isNumber(colSchema) || isString(colSchema) ? {\n        cols: colSchema\n      } : {\n        cols: 'auto'\n      }\n      // else use formbase attribute definition of cols\n      : colAttr ? isPlainObject(colAttr) ? colAttr : isNumber(colAttr) || isString(colAttr) ? {\n        cols: colAttr\n      } : {\n        cols: 'auto'\n      }\n      // if no definition set cols to 'auto'\n      : {\n        cols: 'auto'\n      };\n      this.gridReplaceXS(colObject, 'cols');\n\n      // schema definition of offset\n      var offset = obj.schema.offset;\n      var offsetObject = offset ? isPlainObject(offset) ? offset : {\n        offset: offset\n      } : offset;\n      this.gridMapper(offsetObject, 'offset-');\n      this.gridReplaceXS(offsetObject, 'offset');\n\n      // schema definition of offset\n      var order = obj.schema.order;\n      var orderObject = order ? isPlainObject(order) ? order : {\n        order: order\n      } : order;\n      this.gridMapper(orderObject, 'order-');\n      this.gridReplaceXS(orderObject, 'order');\n      return _objectSpread(_objectSpread(_objectSpread({}, colObject), offsetObject), orderObject);\n    },\n    getRowGroupOrArray: function getRowGroupOrArray(obj) {\n      return obj.schema.row || this.row || rowDefault;\n    },\n    getColGroupOrArray: function getColGroupOrArray(obj) {\n      return obj.schema.col || this.col || colDefault;\n    },\n    //\n    // SANITIZE SLOTS\n    getInjectedScopedSlots: function getInjectedScopedSlots(id, obj) {\n      // <template #slot-inject-thumb-label-key-formbase-path-to-mykey />\n      // extract the verb 'thumb-label' from Slots starting with 'slot-inject' and matching [component-id] and [key]\n      var rx = new RegExp(\"\".concat(injectSlotAppendix, \"-(.*?)-\").concat(keyClassAppendix));\n      return Object.keys(this.$scopedSlots).filter(function (s) {\n        return s.includes(\"\".concat(id).concat(classKeyDelimiter).concat(obj.key.replace(/\\./g, '-'))) && s.includes(injectSlotAppendix);\n      }).map(function (i) {\n        return i.match(rx)[1];\n      });\n    },\n    //\n    // Map Values coming FROM Control, TO Control or DROP on Control\n    toCtrl: function toCtrl(params) {\n      // signature params { value, obj, data, schema }\n      //\n      // manipulate value going to control, function must return a (modified) value\n      // schema:{ name: { type:'text', toCtrl: ( {value} ) => value && value.toUpperCase, ... }, ... }\n      // return isFunction(params.obj.schema && params.obj.schema.toCtrl) ? params.obj.schema.toCtrl(params) : params.value\n      return params.obj.schema && isFunction(params.obj.schema.toCtrl) ? params.obj.schema.toCtrl(params) : params.value;\n    },\n    fromCtrl: function fromCtrl(params) {\n      // signature params { value, obj, data, schema }\n      //\n      // manipulate updated value from control, function must return a (modified) value\n      // schema:{ name: { type:'text', fromCtrl: ( {value} ) => value && value.toUpperCase, ... }, ... }\n      return params.obj.schema && isFunction(params.obj.schema.fromCtrl) ? params.obj.schema.fromCtrl(params) : params.value;\n    },\n    dropCtrl: function dropCtrl(params) {\n      // signature params { value, obj, dragObject, dragEvent, event,data, schema }\n      //\n      // manipulate dropped value from control, function must return a (modified) value\n      // schema:{ name: { type:'text', drop: ( {value} ) => value && value.toUpperCase, ... }, ... }\n      return params.obj.schema && isFunction(params.obj.schema.drop) ? params.obj.schema.drop(params) : params.value;\n    },\n    //\n    // Drag / Drop / DropValue\n    dragstart: function dragstart(event, obj) {\n      if (!obj.schema.drag) return;\n      event.dataTransfer.dropEffect = dropEffect;\n      event.dataTransfer.effectAllowed = dropEffect;\n      var dragEvent = this.onEvent(event, obj);\n      event.dataTransfer.setData('text', JSON.stringify(dragEvent));\n    },\n    dragover: function dragover(event, obj) {\n      return obj.schema.drop ? event.preventDefault() : null;\n    },\n    drop: function drop(event, obj) {\n      if (!obj.schema.drop) return event.preventDefault();\n      // get dragEvent and dragEvent.obj\n      obj.dragEvent = JSON.parse(event.dataTransfer.getData('text'));\n\n      // no drop on drag object\n      if (obj.key === obj.dragEvent.obj.key && obj.id === obj.dragEvent.id) return event.preventDefault();\n      // handle schema.drop function\n      if (isFunction(obj.schema.drop)) obj.value = this.dropValue(obj, event);\n      this.onEvent(event, obj);\n      event.preventDefault();\n    },\n    dropValue: function dropValue(obj, event) {\n      return this.dropCtrl({\n        value: obj.dragEvent.value,\n        obj: obj,\n        event: event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    //\n    // Set Value\n    setValue: function setValue(obj, type) {\n      // Use 'schema.toCtrl' Function for setting a modified Value\n      // __log(\n      //     obj.schema.name,\n      //     this.storeStateData,\n      //     // obj.value\n      // )\n      return obj.schema.type === 'wrap' ? this.toCtrl({\n        value: this.storeStateData,\n        obj: obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      }) : this.toCtrl({\n        value: obj.value,\n        obj: obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    //\n    // EVENTS Get Value from Input & other Events\n    onInput: function onInput(value, obj) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'input';\n      // Value after change in Control\n      value = this.fromCtrl({\n        value: value,\n        obj: obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n      // harmonize undefined or empty strings => null, because 'clearable' in vuetify controls resets to null and not to empty string!\n      value = !value || value === '' ? null : value;\n      // if schema type is number convert to number\n      value = obj.schema.type === 'number' ? Number(value) : value;\n      // update deep nested prop(key) with value\n      this.setObjectByPath(this.storeStateData, obj.key, value);\n      var emitObj = {\n        on: type,\n        id: this.id,\n        index: this.index,\n        params: {\n          index: this.index,\n          lastValue: obj.value\n        },\n        key: obj.key,\n        value: value,\n        obj: obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema,\n        parent: this.parent\n      };\n      this.emitValue(type, emitObj);\n      return emitObj;\n    },\n    onEvent: function onEvent() {\n      var _this = this;\n      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var obj = arguments.length > 1 ? arguments[1] : undefined;\n      var tag = arguments.length > 2 ? arguments[2] : undefined;\n      var text = event && event.srcElement && event.srcElement.innerText;\n      var model = obj.schema.model;\n      var open = obj.schema.open;\n      var index = this.index;\n      // avoid circular JSON in dragstart\n      var parent = event.type !== 'dragstart' ? this.parent : undefined;\n      var emitObj = {\n        on: event.type,\n        id: this.id,\n        index: index,\n        params: {\n          text: text,\n          tag: tag,\n          model: model,\n          open: open,\n          index: index\n        },\n        key: obj.key,\n        value: obj.value,\n        obj: obj,\n        event: event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema,\n        parent: parent\n      };\n      delay(function () {\n        _this.emitValue(event.type, emitObj), onEventDelay;\n      });\n      return emitObj;\n    },\n    onClickOutside: function onClickOutside(event, obj) {\n      if (!obj.schema || !obj.schema.clickOutside) return;\n      if (isFunction(obj.schema.clickOutside)) return obj.schema.clickOutside(obj, event);\n      this.emitValue('clickOutside', {\n        on: 'clickOutside',\n        id: this.id,\n        key: obj.key,\n        value: obj.value,\n        obj: obj,\n        params: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        event: event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    onIntersect: function onIntersect(entries, observer, obj) {\n      var isIntersecting = entries[0].isIntersecting;\n      var index = this.index;\n      this.emitValue('intersect', {\n        on: 'intersect',\n        id: this.id,\n        index: index,\n        key: obj.key,\n        value: obj.value,\n        obj: obj,\n        params: {\n          isIntersecting: isIntersecting,\n          entries: entries,\n          observer: observer\n        },\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    onSwipe: function onSwipe(tag, obj) {\n      this.emitValue('swipe', {\n        on: 'swipe',\n        id: this.id,\n        key: obj.key,\n        value: obj.value,\n        obj: obj,\n        params: {\n          tag: tag\n        },\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    onResize: function onResize(event) {\n      this.emitValue('resize', {\n        on: 'resize',\n        id: this.id,\n        params: {\n          x: window.innerWidth,\n          y: window.innerHeight\n        },\n        event: event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    //\n    // EMIT EVENT\n    emitValue: function emitValue(event, val) {\n      var emitEvent = change.includes(event) ? 'change' : watch.includes(event) ? 'watch' : mouse.includes(event) ? 'mouse' : display.includes(event) ? 'display' : event;\n      if (this.$listeners[\"\".concat(emitEvent, \":\").concat(this.id)]) {\n        this.deprecateEventCustomID(emitEvent);\n        this.deprecateCombinedEvents(emitEvent, event);\n        this.$emit(\"\".concat(emitEvent, \":\").concat(this.id), val); // listen to specific event only\n      } else if (this.$listeners[\"\".concat(emitEvent)]) {\n        this.deprecateCombinedEvents(emitEvent, event);\n        this.$emit(emitEvent, val); // listen to specific event only\n      } else if (this.$listeners[\"\".concat(event, \":\").concat(this.id)]) {\n        this.deprecateEventCustomID(event);\n        this.$emit(\"\".concat(event, \":\").concat(this.id), val); // listen to specific event only\n      } else if (this.$listeners[\"\".concat(event)]) {\n        this.$emit(event, val); // listen to specific event only\n      }\n    },\n    deprecateEventCustomID: function deprecateEventCustomID(ev) {\n      console.warn(\"--- DEPRECATION \".concat(ev, \":\").concat(this.id, \": ----------------------------------------------------------------------------\"));\n      console.warn(\"<v-form-base  @\".concat(ev, \":\").concat(this.id, \"=\\\"handler\\\" /> is deprecated use simplified version <v-form-base  @\").concat(ev, \"=\\\"handler\\\" />\"));\n      console.warn('---------------------------------------------------------------------------------------------');\n    },\n    deprecateCombinedEvents: function deprecateCombinedEvents(emitEvent, event) {\n      if (emitEvent !== event) {\n        console.warn('--- DEPRECATION Combined Listener:  --------------------------------------------------------------------------');\n        console.warn(\"Combined Event-Listener '\".concat(emitEvent, \"' have been removed for better comprehensibility and simplification\"));\n        console.warn('Please use separate listener for each event like <v-form-base  @focus=\"handler\" @input=\"handler\" @blur=\"handler\"/>');\n        console.warn('---------------------------------------------------------------------------------------------');\n      }\n    },\n    //\n    // PREPARE ARRAYS DATA & SCHEMA\n    setObjectByPath: function setObjectByPath(object, path, value) {\n      var _this2 = this;\n      // resolves chained keys (like 'user.address.street') on an object and set the value\n      var pathArray = path.split(pathDelimiter);\n      pathArray.forEach(function (p, ix) {\n        if (ix === pathArray.length - 1) _this2.$set(object, p, value);\n        object = object[p];\n      });\n    },\n    updateArrayFromState: function updateArrayFromState(data, schema) {\n      this.flatCombinedArray.forEach(function (obj) {\n        obj.value = get(data, obj.key, null); // get - lodash\n        obj.schema = get(schema, obj.key, null); // get - lodash\n      });\n    },\n    sanitizeShorthandType: function sanitizeShorthandType(key, schema) {\n      // if key in schema is string only, then handle shorthand definition\n      // schema:{ name:'text' }  => schema:{ name: { type:'text', label: 'name' }\n      return isString(schema) ? {\n        type: schema,\n        label: key\n      } : schema;\n    },\n    flattenObjects: function flattenObjects() {\n      var _this3 = this;\n      var dat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var sch = arguments.length > 1 ? arguments[1] : undefined;\n      var data = {};\n      var schema = {};\n      // Organize Formular using Schema not Data\n      Object.keys(sch).forEach(function (key) {\n        // convert string definition of name:'text' into object name:{type:'text'}\n        sch[key] = _this3.sanitizeShorthandType(key, sch[key]);\n        var bothArray = Array.isArray(dat[key]) && Array.isArray(sch[key]);\n        var datObjectWithoutSchemaType = isPlainObject(dat[key]) && !sch[key].type;\n        var datObjectContainsTypeKey = dat[key] && dat[key].type && sch[key] && sch[key].type;\n        var notInstanceOfFileObject = !(dat[key] instanceof File);\n        if (bothArray || datObjectWithoutSchemaType || datObjectContainsTypeKey && notInstanceOfFileObject) {\n          var _this3$flattenObjects = _this3.flattenObjects(dat[key], sch[key]),\n            flatData = _this3$flattenObjects.data,\n            flatSchema = _this3$flattenObjects.schema;\n          Object.keys(flatData).forEach(function (ii) {\n            data[key + pathDelimiter + ii] = flatData[ii];\n            schema[key + pathDelimiter + ii] = flatSchema[ii];\n          });\n        } else {\n          data[key] = dat[key];\n          schema[key] = sch[key];\n        }\n      });\n      return {\n        data: data,\n        schema: schema\n      };\n    },\n    combineObjectsToArray: function combineObjectsToArray(_ref) {\n      var data = _ref.data,\n        schema = _ref.schema;\n      var arr = [];\n      Object.keys(schema).forEach(function (key) {\n        if (!isPlainObject(schema[key])) {\n          console.warn(\"Schema '\".concat(JSON.stringify(schema), \"' of Prop '\").concat(key, \"' must be a string with value of type key:'text' or a plainobject with at least key:{ type:'text'} definition.  Prop '\").concat(key, \"' will be ignored!\"));\n          return;\n        }\n        arr.push({\n          key: key,\n          value: data[key],\n          schema: schema[key]\n        });\n      });\n      return arr;\n    },\n    flattenAndCombineToArray: function flattenAndCombineToArray(data, schema) {\n      // flatten nested structure of both objects 'data' & 'schema' ...\n      var flattenedObjects = this.flattenObjects(data, schema);\n      // ... and combine them to an array\n      return this.combineObjectsToArray(flattenedObjects);\n    },\n    autogenerateSchema: function autogenerateSchema(value) {\n      var _this4 = this;\n      // generate a minimal default schema from value\n      var schema = JSON.stringify(value, function (key, val) {\n        return val === undefined ? null : val;\n      });\n      schema = JSON.parse(schema, function (key, val) {\n        if (val === null || val === undefined) return defaultSchemaIfValueIsNullOrUndefined(key);\n        if (typeof val === 'string') return defaultSchemaIfValueIsString(key);\n        if (typeof val === 'number') return defaultSchemaIfValueIsNumber(key);\n        if (typeof val === 'boolean') return defaultSchemaIfValueIsBoolean(key);\n        return val;\n      });\n      // assign root props to avoid manipulating prop: schema\n      Object.keys(schema).forEach(function (key) {\n        return _this4.schema[key] = schema[key];\n      });\n    },\n    tryAutogenerateModelStructure: function tryAutogenerateModelStructure(model, schema) {\n      var _this5 = this;\n      // generate or complete an empty model based on schema structure\n\n      Object.keys(schema).forEach(function (key) {\n        // model must be at least an empty Object. It doesn't work with 'null', 'undefined' or any 'primitive value'\n        // Autogeneration from Schema works only if model is an empty Object\n        // if model is NOT an empty Object, no action is applied, otherwise data in model could be changed or modified\n        if (!isEmpty(model[key])) return;\n        var val = schema[key];\n        if (val.type === 'group') {\n          _this5.$set(model, key, {});\n          _this5.tryAutogenerateModelStructure(model[key], val.schema);\n        } else if (val.type === 'array') {\n          _this5.$set(model, key, []);\n          _this5.tryAutogenerateModelStructure(model[key], val.schema);\n        } else if (val.type === 'list') {\n          _this5.$set(model, key, []);\n        } else if (isPlainObject(val) && !val.type) {\n          _this5.$set(model, key, {});\n          _this5.tryAutogenerateModelStructure(model[key], val);\n        }\n        if (Array.isArray(val) && !val.type) {\n          _this5.$set(model, key, []);\n          _this5.tryAutogenerateModelStructure(model[key], val);\n        }\n      });\n    },\n    rebuildArrays: function rebuildArrays(model, schema) {\n      // undefined, null or primitive value for model can't work because you need reference to object for working on\n      if (!model) throw 'Property \\'model\\' is null or undefined. Use \\'<v-form-base :model=\"myModel\" :schema=\"mySchema\" />\\'. myModel must be at least an empty Object.';\n\n      // noise if async loading\n      if (isEmpty(schema) && isEmpty(model)) {\n        console.warn('At least one of the properties \\'model\\' or \\'schema\\' in <v-form-base /> must be at least an empty Object. Ignore this Warning on async loading \\'model\\' or \\'schema\\' ');\n        // return\n      }\n      // generate/complete structure of model\n      this.tryAutogenerateModelStructure(model, schema);\n\n      // no schema defined or empty -> autogenerate basic schema\n      if (isEmpty(schema)) this.autogenerateSchema(model);\n\n      // create flatted working array from schema and value\n      this.flatCombinedArray = this.flattenAndCombineToArray(this.storeStateData, this.storeStateSchema);\n    } //\n  },\n  created: function created() {\n    this.rebuildArrays(this.valueIntern, this.schema);\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}