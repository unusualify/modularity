{"ast":null,"code":"import api from '@/store/api/form';\nimport { FORM, ALERT } from '@/store/mutations';\nimport ACTIONS from '@/store/actions';\nimport { getFormData, getFormFields, getModalFormFields, getSchemaModel } from '@/utils/getFormData.js';\nconst getFieldIndex = (stateKey, field) => {\n  return stateKey.findIndex(f => f.name === field.name);\n};\nconst state = {\n  baseUrl: window[process.env.VUE_APP_NAME].STORE.form.baseUrl || '',\n  inputs: window[process.env.VUE_APP_NAME].STORE.form.inputs,\n  saveUrl: window[process.env.VUE_APP_NAME].STORE.form.saveUrl || '',\n  /**\n   * Form errors after submitting\n   * @type {Object}\n   */\n  errors: {},\n  // fields: window[process.env.VUE_APP_NAME].STORE.form.inputs.forEach(function(el ){\n  //     return {\n  //       name: el.name,\n  //       value: null\n  //     };\n  // }),\n\n  // editedItem: window[process.env.VUE_APP_NAME].STORE.form.inputs.reduce( (a,c) => (a[c.name] = c.default ?? '', a), {}),\n  // editedItem: Object.keys(window[process.env.VUE_APP_NAME].STORE.form.inputs).reduce( (a,c) => (a[window[process.env.VUE_APP_NAME].STORE.form.inputs[c].name] = window[process.env.VUE_APP_NAME].STORE.form.inputs[c].hasOwnProperty('default') ? window[process.env.VUE_APP_NAME].STORE.form.inputs[c].default : '', a), {}),\n  editedItem: getSchemaModel(window[process.env.VUE_APP_NAME].STORE.form.inputs),\n  /**\n   * Force reload on successful submit\n   * @type {Boolean}\n   */\n  reloadOnSuccess: window[process.env.VUE_APP_NAME].STORE.form.reloadOnSuccess || false,\n  /**\n   * Determines if the form should prevent submitting before an input value is pushed into the store\n   * @type {Boolean}\n   */\n  isSubmitPrevented: false,\n  loading: false\n};\n\n// getters\nconst getters = {\n  defaultItem: state => {\n    // __log(state.editedItem)\n    return state.editedItem;\n    // return state.inputs.reduce( (a,c) => (a[c.name] = c.hasOwnProperty('default') ? c.default : '', a), {})\n  }\n};\n\nconst mutations = {\n  [FORM.SET_EDITED_ITEM](state, item) {\n    state.editedItem = Object.assign({}, item);\n  },\n  [FORM.PREVENT_SUBMIT](state) {\n    state.isSubmitPrevented = true;\n  },\n  [FORM.ALLOW_SUBMIT](state) {\n    state.isSubmitPrevented = false;\n  },\n  // ----------- Form fields ----------- //\n  [FORM.EMPTY_FORM_FIELDS](state, status) {\n    state.fields = [];\n  },\n  [FORM.ADD_FORM_FIELDS](state, fields) {\n    state.fields = [...state.fields, ...fields];\n  },\n  [FORM.REPLACE_FORM_FIELDS](state, fields) {\n    state.fields = fields;\n  },\n  [FORM.UPDATE_FORM_FIELD](state, field) {\n    let fieldValue = field.locale ? {} : null;\n    const fieldIndex = getFieldIndex(state.fields, field);\n    // Update existing form field\n    if (fieldIndex !== -1) {\n      if (field.locale) fieldValue = state.fields[fieldIndex].value || {};\n      // remove existing field\n      state.fields.splice(fieldIndex, 1);\n    }\n    if (field.locale) fieldValue[field.locale] = field.value;else fieldValue = field.value;\n    state.fields.push({\n      name: field.name,\n      value: fieldValue\n    });\n  },\n  [FORM.REMOVE_FORM_FIELD](state, fieldName) {\n    state.fields.forEach(function (field, index) {\n      if (field.name === fieldName) state.fields.splice(index, 1);\n    });\n  },\n  // ----------- Modal fields ----------- //\n  [FORM.EMPTY_MODAL_FIELDS](state, status) {\n    state.modalFields = [];\n  },\n  [FORM.REPLACE_MODAL_FIELDS](state, fields) {\n    state.modalFields = fields;\n  },\n  [FORM.UPDATE_MODAL_FIELD](state, field) {\n    let fieldValue = field.locale ? {} : null;\n    const fieldIndex = getFieldIndex(state.modalFields, field);\n\n    // Update existing form field\n    if (fieldIndex !== -1) {\n      if (field.locale) fieldValue = state.modalFields[fieldIndex].value;\n      // remove existing field\n      state.modalFields.splice(fieldIndex, 1);\n    }\n    if (field.locale) fieldValue[field.locale] = field.value;else fieldValue = field.value;\n    state.modalFields.push({\n      name: field.name,\n      value: fieldValue\n    });\n  },\n  [FORM.REMOVE_MODAL_FIELD](state, fieldName) {\n    state.modalFields.forEach(function (field, index) {\n      if (field.name === fieldName) state.modalFields.splice(index, 1);\n    });\n  },\n  // ----------- Form errors and Loading ----------- //\n  [FORM.UPDATE_FORM_LOADING](state, loading) {\n    state.loading = loading || !state.loading;\n  },\n  [FORM.SET_FORM_ERRORS](state, errors) {\n    state.errors = errors;\n  },\n  [FORM.CLEAR_FORM_ERRORS](state) {\n    state.errors = [];\n  },\n  [FORM.UPDATE_FORM_SAVE_TYPE](state, type) {\n    state.type = type;\n  }\n};\nconst actions = {\n  [ACTIONS.SAVE_FORM]({\n    commit,\n    state,\n    getters,\n    rootState,\n    dispatch\n  }, {\n    item = null,\n    callback = null,\n    errorCallback = null\n  }) {\n    commit(FORM.CLEAR_FORM_ERRORS);\n    commit(FORM.UPDATE_FORM_LOADING, true);\n\n    // commit(NOTIFICATION.CLEAR_NOTIF, 'error')\n\n    // update or create etc...\n    // commit(FORM.UPDATE_FORM_SAVE_TYPE, saveType)\n\n    // we can now create our submitted data object out of:\n    // - our just created fields object,\n    // - publication properties\n    // - selected medias and browsers\n    // - created blocks and repeaters\n\n    // const data = getFormData(rootState)\n    const data = item ?? state.editedItem;\n\n    // const method = rootState.publication.createWithoutModal ? 'post' : 'put'\n    let method = 'post';\n    let url = window[process.env.VUE_APP_NAME].ENDPOINTS.store;\n    if (data.hasOwnProperty('id')) {\n      method = 'put';\n      url = window[process.env.VUE_APP_NAME].ENDPOINTS.update.replace(':id', data.id);\n    }\n    api[method](url, data, function (response) {\n      commit(FORM.UPDATE_FORM_LOADING, false);\n      // __log(\n      //   response\n      // )\n      // if (successResponse.data.hasOwnProperty('redirect')) {\n      //   window.location.replace(successResponse.data.redirect)\n      // }\n\n      // if (state.reloadOnSuccess) {\n      //   window.location.reload()\n      // }\n\n      // commit(PUBLICATION.UPDATE_PUBLISH_SUBMIT)\n      // if (successResponse.data.hasOwnProperty('revisions')) {\n      //   commit(REVISION.UPDATE_REV_ALL, successResponse.data.revisions)\n      // }\n      // __log(reload)\n      if (response.data.hasOwnProperty('errors')) {\n        commit(FORM.SET_FORM_ERRORS, response.data.errors);\n      } else if (response.data.hasOwnProperty('variant') && response.data.variant == 'success') {\n        commit(ALERT.SET_ALERT, {\n          message: response.data.message,\n          variant: response.data.variant\n        });\n        if (!data.hasOwnProperty('reload') || data.reload) {\n          dispatch(ACTIONS.GET_DATATABLE);\n        }\n      }\n      if (callback && typeof callback === 'function') callback(response.data);\n    }, function (errorResponse) {\n      commit(FORM.UPDATE_FORM_LOADING, false);\n      if (errorResponse.response.data.hasOwnProperty('exception')) {\n        commit(ALERT.SET_ALERT, {\n          message: 'Your submission could not be processed.',\n          variant: 'error'\n        });\n      } else {\n        dispatch(ACTIONS.HANDLE_ERRORS, errorResponse.response.data);\n        commit(ALERT.SET_ALERT, {\n          message: 'Your submission could not be validated, please fix and retry',\n          variant: 'error'\n        });\n      }\n      if (errorCallback && typeof errorCallback === 'function') errorCallback(errorResponse.data);\n    });\n  },\n  [ACTIONS.HANDLE_ERRORS]({\n    commit,\n    state,\n    getters,\n    rootState\n  }, errors) {\n    const repeaters = rootState.repeaters;\n    // Translate the errors to their respective fields.\n    Object.keys(errors).forEach(errorKey => {\n      const splitted = errorKey.split('.');\n      if (splitted.length >= 4) {\n        const type = splitted[0];\n        const subType = splitted[1];\n        const index = splitted[2];\n        const field = splitted[3];\n        if (type === 'repeaters') {\n          const id = repeaters[subType][index].id;\n          const newErrorKey = `blocks[${id}][${field}]`;\n          errors[newErrorKey] = errors[errorKey];\n        }\n      }\n    });\n    commit(FORM.SET_FORM_ERRORS, errors);\n  }\n};\nexport default {\n  state,\n  getters,\n  actions,\n  mutations\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}