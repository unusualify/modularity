{"ast":null,"code":"/**\n * Media Library\n *\n * Set options for the Media Library and all the medias attached into the form\n */\n\nimport Vue from 'vue';\nimport cloneDeep from 'lodash/cloneDeep';\nimport { MEDIA_LIBRARY } from '../mutations';\nimport ACTIONS from '@/store/actions';\nconst state = {\n  /**\n   * An object of all crops available for cropper component configuration\n   * @type {Object}\n   */\n  crops: window[process.env.VUE_APP_NAME].STORE.medias.crops || {},\n  /**\n   * Display the file name of images\n   * @type {Object}\n   */\n  showFileName: window[process.env.VUE_APP_NAME].STORE.medias.showFileName || false,\n  /**\n   * Define types available in medias library\n   * @type {Array.<string>}\n   */\n  types: window[process.env.VUE_APP_NAME].STORE.medias.types || [],\n  /**\n   * Current type of media library\n   * @type {string}\n   */\n  type: 'image',\n  /**\n   * Connector is used to save media by usage (eg. cover, image, profile...)\n   * @type {string}\n   */\n  connector: null,\n  /**\n   * Define the max of medias that can be select from the media libray\n   * @type {number}\n   */\n  max: 0,\n  /**\n   * Define the maximum filesize allowed to attach in a field from the media library\n   * @type {number}\n   */\n  filesizeMax: 0,\n  /**\n   * Define the min image width allowed to attach in a field from the media library\n   * @type {number}\n   */\n  widthMin: 0,\n  /**\n   * Define the min image height allowed to attach in a field from the media library\n   * @type {number}\n   */\n  heightMin: 0,\n  /**\n   * Restrict the media library navigation between type\n   * @type {Boolean}\n   */\n  strict: true,\n  /**\n   * An object of selected medias by usage (connector)\n   * @type {Object.<string,Object>}\n   */\n  selected: window[process.env.VUE_APP_NAME].STORE.medias.selected || {},\n  /**\n   * An object of configs\n   * @type {Object.<string,Object>}\n   */\n  config: window[process.env.VUE_APP_NAME].STORE.medias.config || {\n    useWysiwyg: false,\n    wysiwygOptions: {}\n  },\n  /**\n   * An array of current uploading medias. When upload is ended, array is reset\n   * @type {Array}\n   */\n  loading: [],\n  /**\n   * The progress value of an upload. When upload is ended, this value is reset to 0.\n   * @type {number}\n   */\n  uploadProgress: 0,\n  /**\n   * An index used when mediaLibrary is open to replace a file\n   * @type {number}\n   */\n  indexToReplace: -1,\n  showModal: window[process.env.VUE_APP_NAME].STORE.medias.openModal || false\n};\n\n// getters\nconst getters = {\n  mediasByBlockId: state => id => {\n    const ids = Object.keys(state.selected).filter(key => key.startsWith(`blocks[${id}]`));\n    const medias = {};\n    ids.forEach(id => medias[id] = state.selected[id]);\n    return medias;\n  }\n};\nconst mutations = {\n  [MEDIA_LIBRARY.UPDATE_MEDIA_TYPE_TOTAL](state, type) {\n    state.types = state.types.map(t => {\n      if (t.value === type.type) t.total = type.total;\n      return t;\n    });\n  },\n  [MEDIA_LIBRARY.UPDATE_REPLACE_INDEX](state, index) {\n    state.indexToReplace = index;\n  },\n  [MEDIA_LIBRARY.INCREMENT_MEDIA_TYPE_TOTAL](state, type) {\n    state.types = state.types.map(t => {\n      if (t.value === type) t.total = t.total + 1;\n      return t;\n    });\n  },\n  [MEDIA_LIBRARY.DECREMENT_MEDIA_TYPE_TOTAL](state, type) {\n    state.types = state.types.map(t => {\n      if (t.value === type) t.total = t.total - 1;\n      return t;\n    });\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIAS](state, {\n    mediaRole,\n    index,\n    media\n  }) {\n    Vue.set(state.selected[mediaRole], index, media);\n  },\n  [MEDIA_LIBRARY.SAVE_MEDIAS](state, medias) {\n    if (state.connector) {\n      const key = state.connector;\n      const existedSelectedConnector = state.selected[key] && state.selected[key].length;\n      if (existedSelectedConnector && state.indexToReplace > -1) {\n        // Replace mode\n        state.selected[key].splice(state.indexToReplace, 1, cloneDeep(medias[0]));\n      } else if (existedSelectedConnector) {\n        // Add mode\n        medias.forEach(function (media) {\n          state.selected[key].push(cloneDeep(media));\n        });\n      } else {\n        // Create mode\n        const newMedias = {};\n        newMedias[key] = medias;\n        state.selected = Object.assign({}, state.selected, newMedias);\n      }\n      state.indexToReplace = -1;\n    }\n  },\n  [MEDIA_LIBRARY.DESTROY_SPECIFIC_MEDIA](state, media) {\n    if (state.selected[media.name]) {\n      state.selected[media.name].splice(media.index, 1);\n      if (state.selected[media.name].length === 0) Vue.delete(state.selected, media.name);\n    }\n    state.connector = null;\n  },\n  [MEDIA_LIBRARY.DESTROY_MEDIAS](state, connector) {\n    if (state.selected[connector]) Vue.delete(state.selected, connector);\n    state.connector = null;\n  },\n  [MEDIA_LIBRARY.REORDER_MEDIAS](state, newValues) {\n    const newMedias = {};\n    newMedias[newValues.name] = newValues.medias;\n    state.selected = Object.assign({}, state.selected, newMedias);\n  },\n  [MEDIA_LIBRARY.PROGRESS_UPLOAD_MEDIA](state, media) {\n    const mediaToUpdate = state.loading.filter(m => m.id === media.id);\n    // Update existing form field\n    if (mediaToUpdate.length) {\n      mediaToUpdate[0].error = false;\n      mediaToUpdate[0].progress = media.progress;\n    } else {\n      state.loading.unshift({\n        id: media.id,\n        name: media.name,\n        progress: media.progress,\n        replacementId: media.replacementId,\n        isReplacement: media.isReplacement\n      });\n    }\n  },\n  [MEDIA_LIBRARY.PROGRESS_UPLOAD](state, uploadProgress) {\n    state.uploadProgress = uploadProgress;\n  },\n  [MEDIA_LIBRARY.DONE_UPLOAD_MEDIA](state, media) {\n    state.loading.forEach(function (m, index) {\n      if (m.id === media.id) state.loading.splice(index, 1);\n    });\n  },\n  [MEDIA_LIBRARY.ERROR_UPLOAD_MEDIA](state, media) {\n    state.loading.forEach(function (m, index) {\n      if (m.id === media.id) {\n        Vue.set(state.loading[index], 'progress', 0);\n        Vue.set(state.loading[index], 'error', true);\n        Vue.set(state.loading[index], 'errorMessage', media.errorMessage);\n      }\n    });\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_CONNECTOR](state, newValue) {\n    if (newValue && newValue !== '') state.connector = newValue;else state.connector = null;\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_MODE](state, newValue) {\n    state.strict = newValue;\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_TYPE](state, newValue) {\n    if (newValue && newValue !== '') state.type = newValue;\n  },\n  [MEDIA_LIBRARY.RESET_MEDIA_TYPE](state) {\n    // __log(state)\n    state.type = state.types[0].value;\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_MAX](state, newValue) {\n    state.max = Math.max(0, newValue);\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_FILESIZE_MAX](state, newValue) {\n    state.filesizeMax = Math.max(0, newValue);\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_WIDTH_MIN](state, newValue) {\n    state.widthMin = Math.max(0, newValue);\n  },\n  [MEDIA_LIBRARY.UPDATE_MEDIA_HEIGHT_MIN](state, newValue) {\n    state.heightMin = Math.max(0, newValue);\n  },\n  [MEDIA_LIBRARY.SET_MEDIA_METADATAS](state, metadatas) {\n    const connector = metadatas.media.context;\n    const medias = state.selected[connector];\n    const newValue = metadatas.value;\n\n    // Save all the custom metadatas here (with or wthout localization)\n    function setMetatadas(mediaToModify) {\n      if (newValue.locale) {\n        // if multi language we will fill an object\n        if (!mediaToModify.metadatas.custom[newValue.id]) {\n          mediaToModify.metadatas.custom[newValue.id] = {};\n        }\n        mediaToModify.metadatas.custom[newValue.id][newValue.locale] = newValue.value;\n      } else {\n        mediaToModify.metadatas.custom[newValue.id] = newValue.value;\n      }\n      return mediaToModify;\n    }\n    if (metadatas.media.hasOwnProperty('index')) {\n      const media = setMetatadas(cloneDeep(medias[metadatas.media.index]));\n      Vue.set(medias, metadatas.media.index, media);\n    }\n  },\n  [MEDIA_LIBRARY.DESTROY_MEDIA_CONNECTOR](state) {\n    state.connector = null;\n  },\n  [MEDIA_LIBRARY.SET_MEDIA_CROP](state, crop) {\n    const key = crop.key;\n    const index = crop.index;\n    const media = state.selected[key][index];\n    function addCrop(mediaToModify) {\n      if (!mediaToModify.crops) mediaToModify.crops = {};\n\n      // save all the crop variants to the media\n      for (const variant in crop.values) {\n        const newValues = {};\n        newValues.name = crop.values[variant].name || variant;\n        newValues.x = crop.values[variant].x;\n        newValues.y = crop.values[variant].y;\n        newValues.width = crop.values[variant].width;\n        newValues.height = crop.values[variant].height;\n        mediaToModify.crops[variant] = newValues;\n      }\n      return mediaToModify;\n    }\n    const newMedia = addCrop(cloneDeep(media));\n    Vue.set(state.selected[key], index, newMedia);\n  },\n  [MEDIA_LIBRARY.ADD_MEDIAS](state, {\n    medias\n  }) {\n    state.selected = Object.assign({}, state.selected, medias);\n  }\n};\nconst actions = {\n  async [ACTIONS.DUPLICATE_BLOCK]({\n    commit,\n    getters\n  }, {\n    block,\n    id\n  }) {\n    // copy medias and update with the provided id\n    const medias = {\n      ...getters.mediasByBlockId(block.id)\n    };\n    const mediaIds = Object.keys(medias);\n    const duplicates = {};\n    mediaIds.forEach(mediaId => duplicates[mediaId.replace(block.id, id)] = [...medias[mediaId]]);\n    commit(MEDIA_LIBRARY.ADD_MEDIAS, {\n      medias: duplicates\n    });\n  }\n};\nexport default {\n  state,\n  getters,\n  mutations,\n  actions\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}