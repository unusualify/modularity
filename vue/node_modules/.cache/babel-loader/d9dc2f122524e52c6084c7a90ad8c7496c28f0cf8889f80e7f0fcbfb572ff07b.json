{"ast":null,"code":"import isEmpty from 'lodash/isEmpty';\n\n/*\n* Gather selected items in a selected object (currently used for medias and browsers)\n* if a block is passed as second argument, we retrieve selected items namespaced by the block id\n* and strip it out from the key to clean things up and make it easier for the backend\n*/\nconst gatherSelected = (selected, block = null) => {\n  return Object.assign({}, ...Object.keys(selected).map(key => {\n    if (block) {\n      if (isBlockField(key, block.id)) {\n        return {\n          [stripOutBlockNamespace(key, block.id)]: selected[key]\n        };\n      }\n    } else if (!key.startsWith('blocks[')) {\n      return {\n        [key]: selected[key]\n      };\n    }\n    return null;\n  }).filter(x => x));\n};\nexport const isBlockField = (name, id) => {\n  return name.startsWith('blocks[' + id + ']');\n};\nexport const stripOutBlockNamespace = (name, id) => {\n  const nameWithoutBlock = name.replace('blocks[' + id + '][', '');\n  return nameWithoutBlock.match(/]/gi).length > 1 ? nameWithoutBlock.replace(']', '') : nameWithoutBlock.slice(0, -1);\n};\nexport const buildBlock = (block, rootState) => {\n  return {\n    id: block.id,\n    type: block.type,\n    editor_name: block.name,\n    // retrieve all fields for this block and clean up field names\n    content: rootState.form.fields.filter(field => {\n      return isBlockField(field.name, block.id);\n    }).map(field => {\n      return {\n        name: stripOutBlockNamespace(field.name, block.id),\n        value: field.value\n      };\n    }).reduce((content, field) => {\n      content[field.name] = field.value;\n      return content;\n    }, {}),\n    medias: gatherSelected(rootState.mediaLibrary.selected, block),\n    browsers: gatherSelected(rootState.browser.selected, block),\n    // gather repeater blocks from the repeater store module\n    blocks: Object.assign({}, ...Object.keys(rootState.repeaters.repeaters).filter(repeaterKey => {\n      return repeaterKey.startsWith('blocks-' + block.id);\n    }).map(repeaterKey => {\n      return {\n        [repeaterKey.replace('blocks-' + block.id + '_', '')]: rootState.repeaters.repeaters[repeaterKey].map(repeaterItem => {\n          return buildBlock(repeaterItem, rootState);\n        })\n      };\n    }))\n  };\n};\nexport const isBlockEmpty = blockData => {\n  return isEmpty(blockData.content) && isEmpty(blockData.browsers) && isEmpty(blockData.medias) && isEmpty(blockData.blocks);\n};\nexport const gatherRepeaters = rootState => {\n  return Object.assign({}, ...Object.keys(rootState.repeaters.repeaters).filter(repeaterKey => {\n    // we start by filtering out repeater blocks\n    return !repeaterKey.startsWith('blocks-');\n  }).map(repeater => {\n    return {\n      [repeater]: rootState.repeaters.repeaters[repeater].map(repeaterItem => {\n        // and for each repeater we build a block for each item\n        const repeaterBlock = buildBlock(repeaterItem, rootState);\n\n        // we want to inline fields in the repeater object\n        // and we don't need the type of component used\n        const fields = repeaterBlock.content;\n        delete repeaterBlock.content;\n        delete repeaterBlock.type;\n\n        // and lastly we want to keep the id to update existing items\n        fields.id = repeaterItem.id;\n        return Object.assign(repeaterBlock, fields);\n      })\n    };\n  }));\n};\nexport const gatherBlocks = rootState => {\n  const used = {\n    ...rootState.blocks.blocks\n  };\n  return Object.keys(used).map(name => {\n    return used[name].map(block => {\n      block.name = name;\n      return buildBlock(block, rootState);\n    });\n  }).flat();\n};\nexport const getFormFields = rootState => {\n  const fields = rootState.form.fields.filter(field => {\n    // we start by filtering out blocks related form fields\n    return !field.name.startsWith('blocks[') && !field.name.startsWith('mediaMeta[');\n  }).reduce((fields, field) => {\n    // and we create a new object with field names as keys,\n    // to inline fields in the submitted data\n    fields[field.name] = field.value;\n    return fields;\n  }, {});\n  return fields;\n};\nexport const getModalFormFields = rootState => {\n  const fields = rootState.form.modalFields.filter(field => {\n    // we start by filtering out blocks related form fields\n    return !field.name.startsWith('blocks[') && !field.name.startsWith('mediaMeta[');\n  }).reduce((fields, field) => {\n    // and we create a new object with field names as keys,\n    // to inline fields in the submitted data\n    fields[field.name] = field.value;\n    return fields;\n  }, {});\n  return fields;\n};\nexport const getFormData = rootState => {\n  const fields = getFormFields(rootState);\n\n  // we can now create our submitted data object out of:\n  // - our just created fields object,\n  // - publication properties\n  // - selected medias and browsers\n  // - created blocks and repeaters\n  const data = Object.assign(fields, {\n    cmsSaveType: rootState.form.type,\n    published: rootState.publication.published,\n    public: rootState.publication.visibility === 'public',\n    publish_start_date: rootState.publication.startDate,\n    publish_end_date: rootState.publication.endDate,\n    languages: rootState.language.all,\n    parent_id: rootState.parents.active,\n    medias: gatherSelected(rootState.mediaLibrary.selected),\n    browsers: gatherSelected(rootState.browser.selected),\n    blocks: gatherBlocks(rootState),\n    repeaters: gatherRepeaters(rootState)\n  });\n  return data;\n};\nexport const getSchemaModel = inputs => {\n  // __log(inputs)\n  let isTreeview = 'custom-input-treeview|treeview';\n  let values = Object.keys(inputs).reduce((a, c) => {\n    if (isTreeview.includes(inputs[c].type)) {\n      a[inputs[c].name] = [];\n    } else if (__isObject(inputs[c])) {\n      a[inputs[c].name] = inputs[c].hasOwnProperty('default') ? inputs[c].default : '';\n    }\n    return a;\n  }, {});\n\n  // __log(values);\n  return values;\n  Object.keys(inputs).reduce((a, c) => (a[inputs[c].name] = inputs[c].hasOwnProperty('default') ? inputs[c].default : '', a), {});\n};\nexport const getSchema = inputs => {\n  // __log(inputs)\n  let values = Object.keys(inputs).reduce((a, c) => {\n    if (__isObject(inputs[c])) {\n      a[inputs[c].name] = inputs[c].hasOwnProperty('default') ? inputs[c].default : '';\n    } else if (Array.isArray(inputs[c])) {\n      a[inputs[c].name] = [];\n    }\n    return a;\n  }, {});\n  return values;\n  Object.keys(inputs).reduce((a, c) => (a[inputs[c].name] = inputs[c].hasOwnProperty('default') ? inputs[c].default : '', a), {});\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}