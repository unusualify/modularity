{"ast":null,"code":"\"use strict\";\n\n/*\n |--------------------------------------------------------------------------\n | Global Helper Definitions\n |--------------------------------------------------------------------------\n |\n | Global js functions are defined here.\n | Functions will be defined with '__' prefix as a unusual enterprise's standard\n |\n */\nglobal.__log = console.log;\nglobal.__isString = obj => {\n  return Object.prototype.toString.call(obj) === '[object String]';\n};\nglobal.__isObject = obj => {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n};\nglobal.__isset = (...args) => {\n  // !No description available for isset. @php.js developers: Please update the function summary text file.\n  // \n  // version: 1103.1210\n  // discuss at: http://phpjs.org/functions/isset\n  // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n  // +   improved by: FremyCompany\n  // +   improved by: Onno Marsman\n  // +   improved by: RafaÅ‚ Kukawski\n  // *     example 1: isset( undefined, true);\n  // *     returns 1: false\n  // *     example 2: isset( 'Kevin van Zonneveld' );\n  // *     returns 2: true\n  var a = args,\n    l = a.length,\n    i = 0,\n    undef;\n  if (l === 0) {\n    throw new Error('Empty isset');\n  }\n  while (i !== l) {\n    if (a[i] === undef || a[i] === null) {\n      return false;\n    }\n    i++;\n  }\n  return true;\n};\nglobal.__getMethods = obj => Object.getOwnPropertyNames(obj).filter(item => typeof obj[item] === 'function');\nglobal.__globalizeMethods = input => {\n  if (Array.isArray(input)) {\n    input.forEach(function (obj) {\n      __getMethods(obj).forEach(function (v) {\n        global[v] = obj[v];\n      });\n    });\n  } else if (__isObject(input)) {\n    __getMethods(obj).forEach(function (v) {\n      global[v] = obj[v];\n    });\n  }\n};\nglobal.__responseHandler = response => {\n  if (__isset(response.data.errors)) {\n    return {\n      status: false,\n      text: errorHandler(response.data.errors)\n    };\n  } else {\n    return {\n      status: true,\n      data: response.data.data\n    };\n  }\n};\n\n/**\n * @param  {} errors\n * !danger, does not work\n * TODO make it work\n */\nglobal.__errorHandler = errors => {\n  var rows = \"\";\n  Object.keys(errors).forEach((key, i) => {\n    rows += `\n            <tr>\n                <td> <strong> ${capitalCase(key)} </strong> </td>\n                <td>  \n                    ${errors[key].join('</br>')}\n                </td>\n            </tr>\n        `;\n  });\n  var html = `\n    <table> \\\n       <tbody> \\\n        ${rows} \\ \n       </tbody> \\\n    </table>`;\n  return html;\n};\nglobal.__functionDefinition = func => {\n  return Function.prototype.toString.call(func);\n};\nglobal.__convertArrayOrObject = (el, key = null) => {\n  if (__isObject(el)) {\n    let object = {};\n    Object.keys(el).forEach(key => {\n      object[key] = __convertArrayOrObject(el[key], key);\n    });\n    return object;\n  } else if (Array.isArray(el)) {\n    let array = [];\n    el.forEach(item => {\n      array.push(__convertArrayOrObject(item));\n    });\n    return array;\n  } else if (typeof el === 'function') {\n    var string = __functionDefinition(el);\n    if (!!key) {\n      string = string.replace(key + '(', 'function (');\n    }\n    return string;\n  } else if (el instanceof RegExp) {\n    return el.toString();\n  } else {\n    return el;\n  }\n};\nglobal.__printDefinition = variable => {\n  // return  __convertArrayOrObject(variable);\n  return JSON.stringify(__convertArrayOrObject(variable));\n};\nif (!Object.equals) {\n  Object.equals = function (object1, object2) {\n    //For the first loop, we only check for types\n    for (const k1 in object1) {\n      //Check for inherited methods and properties - like .equals itself\n      //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\n      //Return false if the return value is different\n      if (object1.hasOwnProperty(k1) != object2.hasOwnProperty(k1)) {\n        return false;\n      }\n      //Check instance type\n      else if (typeof object1[k1] != typeof object2[k1]) {\n        //Different types => not equal\n        return false;\n      }\n    }\n    //Now a deeper check using other objects property names\n    for (const k2 in object2) {\n      //We must check instances anyway, there may be a property that only exists in object2\n      //I wonder, if remembering the checked values from the first loop would be faster or not \n      if (object1.hasOwnProperty(k2) != object2.hasOwnProperty(k2)) {\n        return false;\n      } else if (typeof object1[k2] != typeof object2[k2]) {\n        return false;\n      }\n      //If the property is inherited, do not check any more (it must be equa if both objects inherit it)\n      if (!object1.hasOwnProperty(k2)) continue;\n\n      //Now the detail check and recursion\n\n      //This returns the script back to the array comparing\n      /**REQUIRES Array.equals**/\n      if (object1[k2] instanceof Array && object2[k2] instanceof Array) {\n        // recurse into the nested arrays\n        if (!Array.equals(object1[k2], object2[k2])) return false;\n      } else if (object1[k2] instanceof Object && object2[k2] instanceof Object) {\n        // recurse into another objects\n        //console.log(\"Recursing to compare \", this[propName],\"with\",object2[propName], \" both named \\\"\"+propName+\"\\\"\");\n        if (!Object.equals(object1[k2], object2[k2])) return false;\n      }\n      //Normal value comparison for strings and numbers\n      else if (object1[k2] != object2[k2]) {\n        return false;\n      }\n    }\n    //If everything passed, let's say YES\n    return true;\n  };\n}\nif (!Array.equals) {\n  Array.equals = function (first, array) {\n    // if the other array is a falsy value, return\n    if (!array) return false;\n\n    // compare lengths - can save a lot of time \n    if (first.length != array.length) return false;\n    for (var i = 0, l = first.length; i < l; i++) {\n      // Check if we have nested arrays\n      if (first[i] instanceof Array && array[i] instanceof Array) {\n        // recurse into the nested arrays\n        if (!first[i].equals(array[i])) return false;\n      } else if (first[i] != array[i]) {\n        // Warning - two different object instances will never be equal: {x:20} != {x:20}\n        return false;\n      }\n    }\n    return true;\n  };\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}