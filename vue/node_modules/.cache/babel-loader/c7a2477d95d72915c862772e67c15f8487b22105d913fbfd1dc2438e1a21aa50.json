{"ast":null,"code":"import api from '@/store/api/datatable';\nimport { DATATABLE, ALERT } from '@/store/mutations';\nimport ACTIONS from '@/store/actions';\nimport { setStorage } from '@/utils/localeStorage';\n\n/* NESTED functions */\nconst getObject = (container, id, callback) => {\n  container.forEach(item => {\n    if (item.id === id) callback(item);\n    if (item.children) getObject(item.children, id, callback);\n  });\n};\nconst deepRemoveFromObj = (items, keys = ['id', 'children'], deep = 'children') => {\n  const deepItems = JSON.parse(JSON.stringify(items));\n  deepItems.forEach(obj => {\n    for (const prop in obj) {\n      if (!keys.includes(prop)) {\n        delete obj[prop];\n      }\n      if (prop === deep) {\n        obj[prop] = deepRemoveFromObj(obj[prop]);\n      }\n    }\n  });\n  return deepItems;\n};\nconst state = {\n  baseUrl: window[process.env.VUE_APP_NAME].STORE.datatable.baseUrl || '',\n  name: window[process.env.VUE_APP_NAME].STORE.datatable.name,\n  headers: window[process.env.VUE_APP_NAME].STORE.datatable.headers,\n  // inputs: window[process.env.VUE_APP_NAME].STORE.datatable.inputs,\n  search: window[process.env.VUE_APP_NAME].STORE.datatable.searchText,\n  options: window[process.env.VUE_APP_NAME].STORE.datatable.options,\n  actions: window[process.env.VUE_APP_NAME].STORE.datatable.actions,\n  actionsType: window[process.env.VUE_APP_NAME].STORE.datatable.actionsType,\n  data: window[process.env.VUE_APP_NAME].STORE.datatable.data || [],\n  total: parseInt(window[process.env.VUE_APP_NAME].STORE.datatable.total),\n  filter: window[process.env.VUE_APP_NAME].STORE.datatable.filter || {},\n  mainFilters: window[process.env.VUE_APP_NAME].STORE.datatable.mainFilters || [],\n  bulk: [],\n  // localStorageKey: window[process.env.VUE_APP_NAME].STORE.datatable.localStorageKey || window.location.pathname,\n  loading: false,\n  updateTracker: 0\n\n  // columns: window[process.env.VUE_APP_NAME].STORE.datatable.columns || [],\n  // dialog: false\n};\n\n// getters\nconst getters = {\n  // defaultItem: state => {\n  //   return state.inputs.reduce( (a,c) => (a[c.name] = c.default, a), {})\n  // },\n  totalElements: state => {\n    return state.total;\n  },\n  formatterColumns: state => {\n    return state.headers.filter(h => h.hasOwnProperty('formatter') && !!h.formatter);\n  },\n  editableColumns: state => {\n    return state.headers.filter(h => h.hasOwnProperty('isColumnEditable') && h.isColumnEditable);\n  },\n  rowEditables: state => {\n    return state.headers.filter(h => h.hasOwnProperty('isRowEditable') && h.isRowEditable);\n  },\n  rowActions: state => {\n    return state.actions;\n  },\n  rowActionsType: state => {\n    return state.actionsType;\n  },\n  mainFilters: state => {\n    return state.mainFilters;\n  }\n};\nconst mutations = {\n  [DATATABLE.UPDATE_DATATABLE_OPTIONS](state, options) {\n    state.options = options;\n  },\n  [DATATABLE.UPDATE_DATATABLE_SEARCH](state, search) {\n    state.search = search;\n  },\n  [DATATABLE.UPDATE_DATATABLE_TOTAL](state, total) {\n    state.total = total;\n  },\n  [DATATABLE.UPDATE_DATATABLE_DATA](state, data) {\n    // Each time the data is changing, we reset the bulk ids\n    state.bulk = [];\n    state.data = data;\n  },\n  [DATATABLE.SET_DATATABLE_DIALOG](state, val) {\n    state.dialog = val;\n  },\n  [DATATABLE.UPDATE_DATATABLE_BULK](state, id) {\n    if (state.bulk.indexOf(id) > -1) {\n      state.bulk = state.bulk.filter(function (item) {\n        return item !== id;\n      });\n    } else {\n      state.bulk.push(id);\n    }\n  },\n  [DATATABLE.REPLACE_DATATABLE_BULK](state, ids) {\n    state.bulk = ids;\n  },\n  [DATATABLE.ADD_DATATABLE_COLUMN](state, column) {\n    state.columns.splice(column.index, 0, column.data);\n  },\n  [DATATABLE.REMOVE_DATATABLE_COLUMN](state, columnName) {\n    state.columns.forEach(function (column, index) {\n      if (column.name === columnName) state.columns.splice(index, 1);\n    });\n  },\n  [DATATABLE.UPDATE_DATATABLE_FILTER](state, filter) {\n    state.filter = Object.assign({}, state.filter, filter);\n  },\n  [DATATABLE.CLEAR_DATATABLE_FILTER](state) {\n    state.filter = Object.assign({}, {\n      search: '',\n      status: state.filter.status\n    });\n  },\n  [DATATABLE.UPDATE_DATATABLE_FILTER_STATUS](state, slug) {\n    state.filter.status = slug;\n  },\n  [DATATABLE.UPDATE_DATATABLE_OFFSET](state, offsetNumber) {\n    state.offset = offsetNumber;\n    setStorage(state.localStorageKey + '_page-offset', state.offset);\n  },\n  [DATATABLE.UPDATE_DATATABLE_PAGE](state, pageNumber) {\n    //   state.page = pageNumber\n    // state.options.page = pageNumber\n  },\n  [DATATABLE.UPDATE_DATATABLE_MAXPAGE](state, maxPage) {\n    if (state.page > maxPage) state.page = maxPage;\n    state.maxPage = maxPage;\n  },\n  [DATATABLE.UPDATE_DATATABLE_VISIBLITY](state, columnNames) {\n    setStorage(state.localStorageKey + '_columns-visible', JSON.stringify(columnNames));\n    state.columns.forEach(function (column) {\n      for (let i = 0; i < columnNames.length; i++) {\n        if (columnNames[i] === column.name) {\n          column.visible = true;\n          break;\n        }\n        column.visible = false;\n      }\n    });\n  },\n  [DATATABLE.UPDATE_DATATABLE_SORT](state, column) {\n    const defaultSortDirection = 'asc';\n    if (state.sortKey === column.name) {\n      state.sortDir = state.sortDir === defaultSortDirection ? 'desc' : defaultSortDirection;\n    } else {\n      state.sortDir = defaultSortDirection;\n    }\n    state.sortKey = column.name;\n  },\n  [DATATABLE.UPDATE_DATATABLE_NAV](state, newFilters) {\n    newFilters.forEach(function (newItem) {\n      state.mainFilters.forEach(function (filterItem) {\n        if (filterItem.name === newItem.name) filterItem.number = newItem.number;\n      });\n    });\n  },\n  [DATATABLE.PUBLISH_DATATABLE](state, data) {\n    const id = data.id;\n    const value = data.value;\n    function updateState(index) {\n      if (index >= 0) {\n        if (value === 'toggle') state.data[index].published = !state.data[index].published;else state.data[index].published = value;\n      }\n    }\n    function getIndex(id) {\n      return state.data.findIndex(function (item, index) {\n        return item.id === id;\n      });\n    }\n\n    // bulk\n    if (Array.isArray(id)) {\n      id.forEach(function (itemId) {\n        const index = getIndex(itemId);\n        updateState(index);\n      });\n      state.bulk = [];\n    } else {\n      const index = getIndex(id);\n      updateState(index);\n    }\n  },\n  [DATATABLE.FEATURE_DATATABLE](state, data) {\n    const id = data.id;\n    const value = data.value;\n    function updateState(index) {\n      if (index >= 0) {\n        if (value === 'toggle') state.data[index].featured = !state.data[index].featured;else state.data[index].featured = value;\n      }\n    }\n    function getIndex(id) {\n      return state.data.findIndex(function (item, index) {\n        return item.id === id;\n      });\n    }\n\n    // bulk\n    if (Array.isArray(id)) {\n      id.forEach(function (itemId) {\n        const index = getIndex(itemId);\n        updateState(index);\n      });\n      state.bulk = [];\n    } else {\n      const index = getIndex(id);\n      updateState(index);\n    }\n  },\n  [DATATABLE.UPDATE_DATATABLE_LOADING](state, loading) {\n    state.loading = !state.loading;\n  },\n  [DATATABLE.UPDATE_DATATABLE_NESTED](state, data) {\n    getObject(state.data, data.parentId, item => {\n      item.children = data.val;\n    });\n  },\n  [DATATABLE.UPDATE_DATATABLE_TRACKER](state, newTracker) {\n    state.updateTracker = newTracker ? state.updateTracker + 1 : 0;\n  }\n};\nconst activeOption = (option, key) => {\n  let exist = true;\n  let value;\n  if (key.match(/sortBy|sortDesc/)) {\n    if (option.length > 0) {\n      value = option[0];\n    } else {\n      exist = false;\n    }\n  } else if (key.match(/page|itemsPerPage/)) {\n    value = option;\n  } else {\n    exist = false;\n  }\n  return {\n    active: exist,\n    value\n  };\n};\nconst actions = {\n  [ACTIONS.DELETE_ITEM]({\n    commit,\n    state,\n    dispatch\n  }, {\n    id = null,\n    callback = null,\n    errorCallback = null\n  } = {}) {\n    api.delete(id, function (resp) {\n      commit(ALERT.SET_ALERT, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      if (resp.data.variant == 'success') {\n        dispatch(ACTIONS.GET_DATATABLE);\n        callback(resp.data);\n      } else {\n        errorCallback(resp.data);\n      }\n    });\n  },\n  [ACTIONS.GET_DATATABLE]({\n    commit,\n    state,\n    getters\n  }, {\n    payload = {},\n    callback = null,\n    errorCallback = null\n  } = {}) {\n    // if (!state.loading) {\n\n    const keys = Object.keys(payload);\n    let _changed = keys.length == 0;\n    keys.every(key => {\n      if (__isset(state[key])) {\n        if (__isObject(state[key]) && __isObject(payload[key])) {\n          _changed = !Object.equals(payload[key], state[key]);\n        } else if (Array.isArray(payload[key]) && Array.isArray(state[key])) {\n          _changed = !Array.equals(payload[key], state[key]);\n        } else {\n          _changed = state[key] !== payload[key];\n        }\n      }\n      return !_changed;\n    });\n    if (_changed) {\n      commit(DATATABLE.UPDATE_DATATABLE_LOADING, true);\n      const parameters = {\n        ...Object.keys(state.options).reduce(function (filtered, key) {\n          const {\n            active,\n            value\n          } = activeOption(__isset(payload.options) ? payload.options[key] : state.options[key], key);\n          if (active) {\n            filtered[key] = value;\n          }\n          return filtered;\n        }, {}),\n        ...(state.search != '' ? {\n          search: state.search\n        } : {})\n      };\n\n      // __log(parameters)\n      const params = {\n        // columns: getters.visibleColumnsNames,\n        // filter: state.filter\n        page: __isset(payload.options) ? payload.options.page : state.options.page,\n        itemsPerPage: __isset(payload.options) ? payload.options.itemsPerPage : state.options.itemsPerPage,\n        ...(state.search != '' ? {\n          search: state.search\n        } : {})\n      };\n      api.get(parameters, function (resp) {\n        // __log('ACTIONS.GET_DATATABLE')\n        commit(DATATABLE.UPDATE_DATATABLE_DATA, resp.data);\n        commit(DATATABLE.UPDATE_DATATABLE_TOTAL, resp.total);\n        commit(DATATABLE.UPDATE_DATATABLE_LOADING, false);\n        if (__isset(payload.options)) {\n          commit(DATATABLE.UPDATE_DATATABLE_OPTIONS, payload.options);\n        }\n        if (__isset(payload.search)) {\n          commit(DATATABLE.UPDATE_DATATABLE_SEARCH, payload.search);\n        }\n      });\n    }\n    // }\n  },\n\n  [ACTIONS.SET_DATATABLE_NESTED]({\n    commit,\n    state,\n    dispatch\n  }) {\n    // Get all ids and children ids if any\n    const ids = deepRemoveFromObj(state.data);\n    api.reorder(ids, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n    });\n  },\n  [ACTIONS.SET_DATATABLE]({\n    commit,\n    state,\n    dispatch\n  }) {\n    const ids = state.data.map(row => row.id);\n    api.reorder(ids, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n    });\n  },\n  [ACTIONS.TOGGLE_PUBLISH]({\n    commit,\n    state,\n    dispatch\n  }, row) {\n    api.togglePublished(row, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    }, function (errorResp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: errorResp.data.error.message,\n        variant: 'error'\n      });\n    });\n  },\n  // [ACTIONS.DELETE_ROW] ({ commit, state, dispatch }, row) {\n  //   api.delete(row, function (resp) {\n  //     commit(NOTIFICATION.SET_NOTIF, { message: resp.data.message, variant: resp.data.variant })\n  //     dispatch(ACTIONS.GET_DATATABLE)\n  //   })\n  // },\n  [ACTIONS.DUPLICATE_ROW]({\n    commit,\n    state,\n    dispatch\n  }, row) {\n    api.duplicate(row, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      if (resp.data.hasOwnProperty('redirect')) {\n        window.location.replace(resp.data.redirect);\n      }\n    });\n  },\n  [ACTIONS.RESTORE_ROW]({\n    commit,\n    state,\n    dispatch\n  }, row) {\n    api.restore(row, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    });\n  },\n  [ACTIONS.DESTROY_ROW]({\n    commit,\n    state,\n    dispatch\n  }, row) {\n    api.destroy(row, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    });\n  },\n  [ACTIONS.BULK_PUBLISH]({\n    commit,\n    state,\n    dispatch\n  }, payload) {\n    api.bulkPublish({\n      ids: state.bulk.join(),\n      toPublish: payload.toPublish\n    }, function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    });\n  },\n  [ACTIONS.TOGGLE_FEATURE]({\n    commit,\n    state\n  }, row) {\n    api.toggleFeatured(row, resp => {\n      commit(DATATABLE.FEATURE_DATATABLE, {\n        id: row.id,\n        value: 'toggle'\n      });\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n    });\n  },\n  [ACTIONS.BULK_FEATURE]({\n    commit,\n    state\n  }, payload) {\n    api.bulkFeature({\n      ids: state.bulk.join(),\n      toFeature: payload.toFeature\n    }, function (resp) {\n      commit(DATATABLE.FEATURE_DATATABLE, {\n        id: state.bulk,\n        value: true\n      });\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n    });\n  },\n  [ACTIONS.BULK_DELETE]({\n    commit,\n    state,\n    dispatch\n  }) {\n    api.bulkDelete(state.bulk.join(), function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    });\n  },\n  [ACTIONS.BULK_RESTORE]({\n    commit,\n    state,\n    dispatch\n  }) {\n    api.bulkRestore(state.bulk.join(), function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    });\n  },\n  [ACTIONS.BULK_DESTROY]({\n    commit,\n    state,\n    dispatch\n  }) {\n    api.bulkDestroy(state.bulk.join(), function (resp) {\n      commit(NOTIFICATION.SET_NOTIF, {\n        message: resp.data.message,\n        variant: resp.data.variant\n      });\n      dispatch(ACTIONS.GET_DATATABLE);\n    });\n  }\n};\nexport default {\n  state,\n  getters,\n  actions,\n  mutations\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}