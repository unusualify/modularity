{"ast":null,"code":"// Import\nimport Vue from 'vue';\n// import { getCurrentInstance } from 'vue'\n\nimport { get, isPlainObject, isFunction, isString, isNumber, isEmpty, orderBy, delay } from 'lodash';\nimport VueMask from 'v-mask';\nVue.use(VueMask, {\n  placeholders: {\n    // Info Mask https://github.com/probil/v-mask\n    // '#': null,       // passing `null` removes default placeholder, so `#` is treated as character\n    // D: /\\d/,         // define new placeholder\n  }\n});\n//\n// Declaration\nconst typeToComponent = {\n  // maps schema.type to prop 'type' in v-text-field  - https://www.wufoo.com/html5/\n  text: 'v-text-field',\n  password: 'v-text-field',\n  email: 'v-text-field',\n  tel: 'v-text-field',\n  url: 'v-text-field',\n  search: 'v-text-field',\n  number: 'v-text-field',\n  /*\n        { type:'text, ext:'typeOfTextField', ...}\n        For native <INPUT> type use alternative schema prop ext  -> schema:{ type:'text, ext:'date', ...}\n        correspond to <input type=\"number\" >\n        number: 'v-text-field',   //  { type:'text, ext:'number', ...}\n        range: 'v-text-field',   //  { type:'text, ext:'range', ...}\n        date: 'v-text-field',    //  { type:'text, ext:'date', ...}\n        time: 'v-text-field',    //  { type:'text, ext:'time', ...}\n        color: 'v-text-field',   //  { type:'text, ext:'color', ...}\n      */\n\n  date: 'v-date-picker',\n  time: 'v-time-picker',\n  color: 'v-color-picker',\n  /*\n        INFO: 3 Types of PICKER DATE / TIME / COLOR\n        Date-Native Input    - schema:{ type:'text, ext:'date', ...}\n        Date-Picker          - schema:{ type:'date', ...}\n        Date-Picker-Textmenu     - schema:{ type:'date', ext:'text'...}\n      */\n\n  // map schema.type to vuetify-control (vuetify 2.0)\n  img: 'v-img',\n  textarea: 'v-textarea',\n  range: 'v-slider',\n  file: 'v-file-input',\n  switch: 'v-switch',\n  checkbox: 'v-checkbox',\n  card: 'v-card'\n  /*\n        HOW TO USE CUSTOM Components\n        1)\n          Name and Register your Custom-Control Component globally in 'main.js'\n          but avoid collision with registered names of Vuetify - Controls\n          See: https://vuejs.org/v2/guide/components-registration.html\n           Vue.component('custom-component', () => import('@/components/custom-component.vue') )\n         2)\n          use it in Schema\n           mySchema: { myCustom: { type: 'custom-component' }\n         3) // custom-component.vue\n          <template>\n            <v-text-field v-model=\"inp\"  label=\"Basic\"></v-text-field>\n          </template>\n          <script>\n            export default {\n              props: ['type','value', 'obj'],\n              computed:{\n                inp:{\n                  get(){  return this.value},\n                  set(v){ this.$emit('input', v)}\n                }\n              }\n            }\n          < /script>\n      */\n};\n\nconst orderDirection = 'ASC';\nconst pathDelimiter = '.';\nconst classKeyDelimiter = '-';\nconst defaultID = 'form-base';\nconst isPicker = 'date|time|color';\nconst onEventDelay = 1; // ms\n\nconst mouse = 'mouseenter|mouseleave';\nconst change = 'input|click'; // event change collects events 'input|click'\nconst watch = 'focus|input|click|blur'; // event watch collects events 'focus|input|click|blur'\nconst display = 'resize|swipe|intersect'; // event watch collects events 'resize|swipe|intersect'\n\nconst topAppendix = 'top';\nconst bottomAppendix = 'bottom';\nconst slotAppendix = 'slot';\nconst tooltipAppendix = 'tooltip';\nconst injectAppendix = 'inject';\nconst itemClassAppendix = 'item';\nconst typeClassAppendix = 'type';\nconst keyClassAppendix = 'key';\nconst arrayClassAppendix = 'array';\nconst propertyClassAppendix = 'prop';\nconst injectSlotAppendix = `${slotAppendix}-${injectAppendix}`;\nconst arraySlotAppendix = `${slotAppendix}-${arrayClassAppendix}`;\nconst topSlotAppendix = `${slotAppendix}-${topAppendix}`;\nconst itemSlotAppendix = `${slotAppendix}-${itemClassAppendix}`;\nconst bottomSlotAppendix = `${slotAppendix}-${bottomAppendix}`;\nconst tooltipSlotAppendix = `${slotAppendix}-${tooltipAppendix}`;\nconst clear = 'clear';\nconst button = 'button';\nconst treeview = 'treeview';\nconst list = 'list';\nconst focus = 'focus';\nconst blur = 'blur';\nconst append = 'append';\nconst appendOuter = 'append-outer';\nconst prepend = 'prepend';\nconst prependInner = 'prepend-inner';\nconst hour = 'hour';\nconst minute = 'minute';\nconst second = 'second';\n\n// symbol on drop\nconst dropEffect = 'move'; // 'copy, link, move\n// Default row setting if no row-attribute defined\nconst rowDefault = {\n  noGutters: true\n}; // { noGutters:true, justify:'center', align:'center' }\n\n// Default col setting, overrideable by prop col or by schema.col definition\n// Default col setting, overrideable by prop flex or by schema.flex definition (flex is DEPRECATED use col instead)\nconst colDefault = {\n  cols: 'auto'\n}; // { cols:12, sm: 6, md:4, lg:3, xl:2}\n\n// Mapper for Autogeneration of Schema from Value\nconst defaultSchemaIfValueIsNullOrUndefined = key => ({\n  type: 'text',\n  label: key\n});\nconst defaultSchemaIfValueIsString = key => ({\n  type: 'text',\n  label: key\n});\nconst defaultSchemaIfValueIsNumber = key => ({\n  type: 'number',\n  label: key\n});\nconst defaultSchemaIfValueIsBoolean = key => ({\n  type: 'checkbox',\n  label: key\n});\n// Menu triggered DateTimePicker Default\nconst defaultPickerSchemaText = {\n  type: 'text',\n  readonly: true\n};\nconst defaultPickerSchemaMenu = {\n  closeOnContentClick: false,\n  transition: 'scale-transition',\n  nudgeRight: 32,\n  maxWidth: '290px',\n  minWidth: '290px'\n};\n// type wrap or group - if no typeInt defined take default\nconst defaultInternGroupType = 'v-card';\n//\nexport default {\n  name: 'VFormBase',\n  props: {\n    id: {\n      type: String,\n      default: defaultID\n    },\n    rootId: {\n      type: String,\n      default: defaultID\n    },\n    row: {\n      type: [Object]\n    },\n    col: {\n      type: [Object, Number, String]\n    },\n    flex: {\n      type: [Object, Number, String]\n    },\n    value: {\n      type: [Object, Array],\n      default: () => null\n    },\n    model: {\n      type: [Object, Array],\n      default: () => ({})\n    },\n    schema: {\n      type: [Object, Array],\n      default: () => ({})\n    }\n  },\n  data() {\n    return {\n      flatCombinedArray: [],\n      clear,\n      button,\n      treeview,\n      list,\n      focus,\n      blur,\n      append,\n      appendOuter,\n      prepend,\n      prependInner,\n      hour,\n      minute,\n      second\n    };\n  },\n  computed: {\n    valueIntern() {\n      // use <formbase :model=\"myData\" />  ->  legacy code <formbase :value=\"myData\" />\n      const model = this.model || this.value;\n      this.updateArrayFromState(model, this.schema);\n      return model;\n    },\n    parent() {\n      let p = this;\n      if (p.$parent && p.$parent.$parent) {\n        while (p.id.startsWith(p.$parent.$parent.id + '-')) {\n          p = p.$parent.$parent;\n        }\n      }\n      return p;\n    },\n    index() {\n      const m = this.id && this.id.match(/\\d+/g);\n      return m ? m.map(Number) : null;\n    },\n    getRow() {\n      return this.row || rowDefault;\n    },\n    flatCombinedArraySorted() {\n      return orderBy(this.flatCombinedArray, ['schema.sort'], [orderDirection]);\n    },\n    storeStateData() {\n      this.updateArrayFromState(this.valueIntern, this.schema);\n      return this.valueIntern;\n    },\n    storeStateSchema() {\n      this.updateArrayFromState(this.valueIntern, this.schema);\n      return this.schema;\n    }\n  },\n  watch: {\n    schema: function (newSchema) {\n      this.rebuildArrays(this.valueIntern, newSchema);\n      this.schema = newSchema;\n    }\n  },\n  methods: {\n    // MAP TYPE\n    mapTypeToComponent(type) {\n      // merge global registered components into typeToComponent Object\n      const allTypeComponents = {\n        ...typeToComponent,\n        ...Vue.options.components\n      };\n      // const typeToComponent -> maps type to according v-component\n      // ie. schema:{ type:'password', ... } to specific vuetify-control or default to v-text-field'\n      return allTypeComponents[type] ? allTypeComponents[type] : `v-${type}`;\n    },\n    // CHECK FOR TYPE: DATE, TIME OR COLOR and EXT: TEXT\n    isDateTimeColorTypeAndExtensionText(obj) {\n      return isPicker.includes(obj.schema.type) && obj.schema.ext === 'text';\n    },\n    // CHECK FOR EXT: DATE, TIME OR COLOR\n    isDateTimeColorExtension(obj) {\n      return isPicker.includes(obj.schema.ext);\n    },\n    // BIND SCHEMA TEXT OPTIONS\n    bindOptions(b) {\n      // schema.options in RADIO/BUTTON\n      return isString(b) ? {\n        value: b,\n        label: b\n      } : b;\n    },\n    bindSchemaText(obj) {\n      return {\n        ...defaultPickerSchemaText,\n        ...obj.schema.text\n      };\n    },\n    bindSchemaMenu(obj) {\n      return {\n        ...defaultPickerSchemaMenu,\n        ...obj.schema.menu\n      };\n    },\n    bindSchema(obj) {\n      return obj.schema;\n    },\n    suspendClickAppend(obj) {\n      // select|combobox|autocomplete -> suspend 'click:append' for working down arrow\n      return /(select|combobox|autocomplete)/.test(obj.schema.type) ? '' : 'click:append';\n    },\n    searchInputSync(obj) {\n      // schema.searchInput ->   bind 'search-input'\n      return typeof obj.schema.searchInput !== 'undefined' ? 'search-input' : '';\n    },\n    // EXT TYPE\n    checkExtensionType(obj) {\n      // For native <INPUT> type use prop 'ext'\n      // { type:'text', ext:'range', ... } -> use native Input Type 'range' instead of slider\n      // { type:'text', ext:'number', ...} -> use native Input Type 'number'\n      return obj.schema.ext || obj.schema.type;\n    },\n    // V-INTERN TYPE\n    checkInternType(obj) {\n      // If vuetify component needs a 'type' prop for working  - ie. datepicker uses type:'month'\n      // { type:'date', ext:'text', typeInt:'month' ...} -> use v-date-picker menu with intern Type 'month'\n      return obj.schema.typeInt || obj.schema.type;\n    },\n    checkInternGroupType(obj) {\n      //  in type 'wrap|group' you can define with typeInt: a component as group - schema: { group1: { type:'wrap', typeInt:'v-card', ... } ...}\n      const typeInt = obj.schema.typeInt || defaultInternGroupType;\n      return typeInt.startsWith('v-') ? typeInt : `v-${typeInt}`;\n    },\n    // GET ITERATION KEY FOR TYPE ARRAY\n    getKeyForArray(id, obj, item, index) {\n      // IMPORTANT if you want to add or remove items in type:'array'\n      // more Info ->\n      // https://forum.vuejs.org/t/after-splicing-an-object-wrong-item-disappears-from-view/9247/4\n      // https://stackoverflow.com/questions/45655090/vue-array-splice-removing-wrong-item-from-list\n\n      // create for iteration v-for an uniqe key from each object in array using index and time.hash\n      // or define your key index by defining a key property\n      // MODEL\n      // arrayTasks: [{ trace:'100', label:'A'}, ...  ]\n      // SCHEMA\n      // arrayTasks: { type:'array', schema:{ ... } }                                                      DEFAULT KEY -> KEY id-key-index   'arrayTasks-0'\n      // arrayTasks: { type:'array', key:'trace', schema:{ trace: { type:'text'}, ... } }                              -> KEY trace            100\n      // arrayTasks: { type:'array', key:['trace','label'], schema:{ trace: { type:'text'}, label: { type:'text'} } }  -> KEY trace_label      100_A\n\n      // IMPORTANT! Key should not contain an EDITABLE prop, because of re-iteration on any change\n\n      const k = obj.schema.key;\n      return k ? Array.isArray(k) ? k.map(i => item[i]).join('_') : item[k] : !isNaN(index) ? `${id}-${obj.key}-${index}` : index;\n    },\n    //\n    // GET IMG SOURCE\n    getImageSource(obj) {\n      // if exist get source from src otherwise join schema.base & value & schema.tail\n      return obj.schema.src ? obj.schema.src : `${obj.schema.base}${obj.value}${obj.schema.tail}`;\n    },\n    //\n    // ICON\n    getIconValue(obj) {\n      // icon: try schema.label or if undefined use value\n      return obj.schema.label ? obj.schema.label : this.setValue(obj);\n    },\n    //\n    // TOOLTIP\n    getShorthandTooltip(schemaTooltip) {\n      // check if tooltip is typeof string ->  shorthand { bottom:true, label: obj.schema.tooltip} otherwise take original object\n      return isString(schemaTooltip) ? {\n        bottom: true,\n        label: schemaTooltip\n      } : schemaTooltip;\n    },\n    getShorthandTooltipLabel(schemaTooltip) {\n      // check if tooltip is typeof string ->  return Label\n      return isString(schemaTooltip) ? schemaTooltip : schemaTooltip && schemaTooltip.label;\n    },\n    //\n    // FORM SLOTS\n    getFormTopSlot() {\n      // Slot for Top Line in Formbase -> 'slot-formbase-top'\n      return `${topSlotAppendix}-${this.id}`;\n    },\n    getFormBottomSlot() {\n      // Slot for Bottom Line in Formbase -> 'slot-formbase-bottom'\n      return `${bottomSlotAppendix}-${this.id}`;\n    },\n    //\n    // KEY SLOTS\n    getKeyInjectSlot(obj, inject) {\n      // get slot starting with 'slot-inject' and inject verb 'thumb-label'   -> 'slot-inject-thumb-label-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${injectSlotAppendix}-${inject}-${keyClassAppendix}`);\n    },\n    getKeyTopSlot(obj) {\n      // get Key specific name by replacing '.' with '-' and prepending 'slot-top'  -> 'slot-top-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${topSlotAppendix}-${keyClassAppendix}`);\n    },\n    getKeyItemSlot(obj) {\n      // get Key specific name by replacing '.' with '-' and prepending 'slot-item'  -> 'slot-item-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${itemSlotAppendix}-${keyClassAppendix}`);\n    },\n    getKeyBottomSlot(obj) {\n      // get Key specific name by replacing '.' with '-' and prepending 'slot-bottom'  -> 'slot-bottom-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${bottomSlotAppendix}-${keyClassAppendix}`);\n    },\n    getKeyTooltipSlot(obj) {\n      // matches Key specific Tooltip | name by replacing '.' with '-' and prepending 'slot-bottom'  -> 'slot-tooltip-key-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${tooltipSlotAppendix}-${keyClassAppendix}`);\n    },\n    getTooltipSlot(obj) {\n      // default tooltip slot matches all keys\n      return `${tooltipSlotAppendix}`;\n    },\n    //\n    // ARRAY SLOTS\n    getArrayTopSlot(obj) {\n      // slot each item from array  -> 'slot-top-array-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${topSlotAppendix}-${arrayClassAppendix}`);\n    },\n    getArrayItemSlot(obj) {\n      // slot each item from array  -> 'slot-top-array-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${itemSlotAppendix}-${arrayClassAppendix}`);\n    },\n    getArrayBottomSlot(obj) {\n      // slot each item from array   -> 'slot-bottom-array-formbase-address-city'\n      return this.getKeyClassNameWithAppendix(obj, `${bottomSlotAppendix}-${arrayClassAppendix}`);\n    },\n    //\n    // TYPE SLOTS\n    getTypeTopSlot(obj) {\n      // get Type specific slot name  -> 'slot-top-type-radio'\n      return this.getTypeClassNameWithAppendix(obj, `${topSlotAppendix}-${typeClassAppendix}`);\n    },\n    getTypeItemSlot(obj) {\n      // get Type specific slot name  -> 'slot-item-type-radio'\n      return this.getTypeClassNameWithAppendix(obj, `${itemSlotAppendix}-${typeClassAppendix}`);\n    },\n    getTypeBottomSlot(obj) {\n      // get Type specific slot name  -> 'slot-bottom-type-radio'\n      return this.getTypeClassNameWithAppendix(obj, `${bottomSlotAppendix}-${typeClassAppendix}`);\n    },\n    //\n    // CLASS Names\n    getPropertyClassNameWithAppendix(obj, appendix) {\n      // get PROP specific name by app-/prepending 'appendix-' and replacing '.' with '-' in nested key path  -> 'controls switch'\n      return obj.key ? obj.key.split(pathDelimiter).map(s => `${appendix ? appendix + classKeyDelimiter : ''}${s}`).join(' ') : '';\n    },\n    getPropertyClassName(obj) {\n      return this.getPropertyClassNameWithAppendix(obj, propertyClassAppendix);\n    },\n    getKeyClassNameWithAppendix(obj, appendix) {\n      // get KEY specific name by app-/prepending 'appendix-' and replacing '.' with '-' in nested key path  -> 'top-slot-address-city'\n      return `${appendix ? appendix + classKeyDelimiter : ''}${this.id ? this.id + classKeyDelimiter : ''}${obj.key.replace(/\\./g, '-')}`;\n      // return `${appendix ? appendix + classKeyDelimiter : ''}${obj.key.replace(/\\./g, '-')}`\n    },\n\n    getKeyClassName(obj) {\n      return this.getKeyClassNameWithAppendix(obj, keyClassAppendix);\n    },\n    getTypeClassNameWithAppendix(obj, appendix) {\n      // get TYPE specific class name by prepending '-type' -> 'type-checkbox'\n      return `${appendix ? appendix + classKeyDelimiter : ''}${this.id ? this.id + classKeyDelimiter : ''}${obj.schema.type}`;\n      // return `${appendix + classKeyDelimiter}${obj.schema.type}`\n    },\n\n    getTypeClassName(obj) {\n      return this.getTypeClassNameWithAppendix(obj, typeClassAppendix);\n    },\n    getClassName(obj) {\n      // combines all into a single classname\n      // class => ie. 'item type-checkbox key-address-zip prop-adress prop-zip'\n      return `${itemClassAppendix} ${this.getTypeClassName(obj)} ${this.getKeyClassName(obj)} ${this.getPropertyClassName(obj)}`;\n    },\n    //\n    // GRID\n    gridMapper(obj, prepender) {\n      if (obj) {\n        ['sm', 'md', 'lg', 'xl'].map(k => {\n          if (obj[k]) {\n            obj[prepender + k] = obj[k];\n            delete obj[k];\n          }\n        });\n      }\n    },\n    gridReplaceXS(obj, replacer) {\n      // see vuetify Grid - replace Prop XS -V1.5 with COLS, ORDER, OFFSET - V2.0\n      // xs must be replaced in new Vuetify 2.0 Grid with cols, offset, order\n      if (obj && obj.xs) {\n        obj[replacer] = obj.xs;\n        delete obj.xs;\n      }\n    },\n    getGridAttributes(obj) {\n      // FLEX DEPRECATED use COL instead of FLEX\n      // flex:{ xs|sm|md|lg } - value:number|string\n\n      // col:{ cols|sm|md|lg|xl } - value:number|string\n      // order:{ order|sm|md|lg|xl|order-sm|order-md|order-lg|order-xl } - value:number|string\n      // offset:{ offset|sm|md|lg|xl|offset-sm|offset-md|offset-lg|offset-xl } - value:number|string\n\n      const colSchema = obj.schema.col || obj.schema.flex;\n      const colAttr = this.col || this.flex || colDefault;\n      const colObject = colSchema\n      // if available use schema definition of cols\n      ? isPlainObject(colSchema) ? colSchema : isNumber(colSchema) || isString(colSchema) ? {\n        cols: colSchema\n      } : {\n        cols: 'auto'\n      }\n      // else use formbase attribute definition of cols\n      : colAttr ? isPlainObject(colAttr) ? colAttr : isNumber(colAttr) || isString(colAttr) ? {\n        cols: colAttr\n      } : {\n        cols: 'auto'\n      }\n      // if no definition set cols to 'auto'\n      : {\n        cols: 'auto'\n      };\n      this.gridReplaceXS(colObject, 'cols');\n\n      // schema definition of offset\n      const offset = obj.schema.offset;\n      const offsetObject = offset ? isPlainObject(offset) ? offset : {\n        offset\n      } : offset;\n      this.gridMapper(offsetObject, 'offset-');\n      this.gridReplaceXS(offsetObject, 'offset');\n\n      // schema definition of offset\n      const order = obj.schema.order;\n      const orderObject = order ? isPlainObject(order) ? order : {\n        order\n      } : order;\n      this.gridMapper(orderObject, 'order-');\n      this.gridReplaceXS(orderObject, 'order');\n      return {\n        ...colObject,\n        ...offsetObject,\n        ...orderObject\n      };\n    },\n    getRowGroupOrArray(obj) {\n      return obj.schema.row || this.row || rowDefault;\n    },\n    getColGroupOrArray(obj) {\n      return obj.schema.col || this.col || colDefault;\n    },\n    //\n    // SANITIZE SLOTS\n    getInjectedScopedSlots(id, obj) {\n      // <template #slot-inject-thumb-label-key-formbase-path-to-mykey />\n      // extract the verb 'thumb-label' from Slots starting with 'slot-inject' and matching [component-id] and [key]\n      const rx = new RegExp(`${injectSlotAppendix}-(.*?)-${keyClassAppendix}`);\n      return Object.keys(this.$scopedSlots).filter(s => s.includes(`${id}${classKeyDelimiter}${obj.key.replace(/\\./g, '-')}`) && s.includes(injectSlotAppendix)).map(i => i.match(rx)[1]);\n    },\n    //\n    // Map Values coming FROM Control, TO Control or DROP on Control\n    toCtrl(params) {\n      // signature params { value, obj, data, schema }\n      //\n      // manipulate value going to control, function must return a (modified) value\n      // schema:{ name: { type:'text', toCtrl: ( {value} ) => value && value.toUpperCase, ... }, ... }\n      // return isFunction(params.obj.schema && params.obj.schema.toCtrl) ? params.obj.schema.toCtrl(params) : params.value\n      return params.obj.schema && isFunction(params.obj.schema.toCtrl) ? params.obj.schema.toCtrl(params) : params.value;\n    },\n    fromCtrl(params) {\n      // signature params { value, obj, data, schema }\n      //\n      // manipulate updated value from control, function must return a (modified) value\n      // schema:{ name: { type:'text', fromCtrl: ( {value} ) => value && value.toUpperCase, ... }, ... }\n      return params.obj.schema && isFunction(params.obj.schema.fromCtrl) ? params.obj.schema.fromCtrl(params) : params.value;\n    },\n    dropCtrl(params) {\n      // signature params { value, obj, dragObject, dragEvent, event,data, schema }\n      //\n      // manipulate dropped value from control, function must return a (modified) value\n      // schema:{ name: { type:'text', drop: ( {value} ) => value && value.toUpperCase, ... }, ... }\n      return params.obj.schema && isFunction(params.obj.schema.drop) ? params.obj.schema.drop(params) : params.value;\n    },\n    //\n    // Drag / Drop / DropValue\n    dragstart(event, obj) {\n      if (!obj.schema.drag) return;\n      event.dataTransfer.dropEffect = dropEffect;\n      event.dataTransfer.effectAllowed = dropEffect;\n      const dragEvent = this.onEvent(event, obj);\n      event.dataTransfer.setData('text', JSON.stringify(dragEvent));\n    },\n    dragover(event, obj) {\n      return obj.schema.drop ? event.preventDefault() : null;\n    },\n    drop(event, obj) {\n      if (!obj.schema.drop) return event.preventDefault();\n      // get dragEvent and dragEvent.obj\n      obj.dragEvent = JSON.parse(event.dataTransfer.getData('text'));\n\n      // no drop on drag object\n      if (obj.key === obj.dragEvent.obj.key && obj.id === obj.dragEvent.id) return event.preventDefault();\n      // handle schema.drop function\n      if (isFunction(obj.schema.drop)) obj.value = this.dropValue(obj, event);\n      this.onEvent(event, obj);\n      event.preventDefault();\n    },\n    dropValue(obj, event) {\n      return this.dropCtrl({\n        value: obj.dragEvent.value,\n        obj,\n        event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    //\n    // Set Value\n    setValue(obj, type) {\n      // Use 'schema.toCtrl' Function for setting a modified Value\n      // __log(\n      //     obj.schema.name,\n      //     this.storeStateData,\n      //     // obj.value\n      // )\n      return obj.schema.type === 'wrap' ? this.toCtrl({\n        value: this.storeStateData,\n        obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      }) : this.toCtrl({\n        value: obj.value,\n        obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    //\n    // EVENTS Get Value from Input & other Events\n    onInput(value, obj, type = 'input') {\n      // Value after change in Control\n      value = this.fromCtrl({\n        value,\n        obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n      // harmonize undefined or empty strings => null, because 'clearable' in vuetify controls resets to null and not to empty string!\n      value = !value || value === '' ? null : value;\n      // if schema type is number convert to number\n      value = obj.schema.type === 'number' ? Number(value) : value;\n      // update deep nested prop(key) with value\n      this.setObjectByPath(this.storeStateData, obj.key, value);\n      const emitObj = {\n        on: type,\n        id: this.id,\n        index: this.index,\n        params: {\n          index: this.index,\n          lastValue: obj.value\n        },\n        key: obj.key,\n        value,\n        obj,\n        data: this.storeStateData,\n        schema: this.storeStateSchema,\n        parent: this.parent\n      };\n      this.emitValue(type, emitObj);\n      return emitObj;\n    },\n    onEvent(event = {}, obj, tag) {\n      const text = event && event.srcElement && event.srcElement.innerText;\n      const model = obj.schema.model;\n      const open = obj.schema.open;\n      const index = this.index;\n      // avoid circular JSON in dragstart\n      const parent = event.type !== 'dragstart' ? this.parent : undefined;\n      const emitObj = {\n        on: event.type,\n        id: this.id,\n        index,\n        params: {\n          text,\n          tag,\n          model,\n          open,\n          index\n        },\n        key: obj.key,\n        value: obj.value,\n        obj,\n        event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema,\n        parent\n      };\n      delay(() => {\n        this.emitValue(event.type, emitObj), onEventDelay;\n      });\n      return emitObj;\n    },\n    onClickOutside(event, obj) {\n      if (!obj.schema || !obj.schema.clickOutside) return;\n      if (isFunction(obj.schema.clickOutside)) return obj.schema.clickOutside(obj, event);\n      this.emitValue('clickOutside', {\n        on: 'clickOutside',\n        id: this.id,\n        key: obj.key,\n        value: obj.value,\n        obj,\n        params: {\n          x: event.clientX,\n          y: event.clientY\n        },\n        event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    onIntersect(entries, observer, obj) {\n      const isIntersecting = entries[0].isIntersecting;\n      const index = this.index;\n      this.emitValue('intersect', {\n        on: 'intersect',\n        id: this.id,\n        index,\n        key: obj.key,\n        value: obj.value,\n        obj,\n        params: {\n          isIntersecting,\n          entries,\n          observer\n        },\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    onSwipe(tag, obj) {\n      this.emitValue('swipe', {\n        on: 'swipe',\n        id: this.id,\n        key: obj.key,\n        value: obj.value,\n        obj,\n        params: {\n          tag\n        },\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    onResize(event) {\n      this.emitValue('resize', {\n        on: 'resize',\n        id: this.id,\n        params: {\n          x: window.innerWidth,\n          y: window.innerHeight\n        },\n        event,\n        data: this.storeStateData,\n        schema: this.storeStateSchema\n      });\n    },\n    //\n    // EMIT EVENT\n    emitValue(event, val) {\n      const emitEvent = change.includes(event) ? 'change' : watch.includes(event) ? 'watch' : mouse.includes(event) ? 'mouse' : display.includes(event) ? 'display' : event;\n      if (this.$listeners[`${emitEvent}:${this.id}`]) {\n        this.deprecateEventCustomID(emitEvent);\n        this.deprecateCombinedEvents(emitEvent, event);\n        this.$emit(`${emitEvent}:${this.id}`, val); // listen to specific event only\n      } else if (this.$listeners[`${emitEvent}`]) {\n        this.deprecateCombinedEvents(emitEvent, event);\n        this.$emit(emitEvent, val); // listen to specific event only\n      } else if (this.$listeners[`${event}:${this.id}`]) {\n        this.deprecateEventCustomID(event);\n        this.$emit(`${event}:${this.id}`, val); // listen to specific event only\n      } else if (this.$listeners[`${event}`]) {\n        this.$emit(event, val); // listen to specific event only\n      }\n    },\n\n    deprecateEventCustomID(ev) {\n      console.warn(`--- DEPRECATION ${ev}:${this.id}: ----------------------------------------------------------------------------`);\n      console.warn(`<v-form-base  @${ev}:${this.id}=\"handler\" /> is deprecated use simplified version <v-form-base  @${ev}=\"handler\" />`);\n      console.warn('---------------------------------------------------------------------------------------------');\n    },\n    deprecateCombinedEvents(emitEvent, event) {\n      if (emitEvent !== event) {\n        console.warn('--- DEPRECATION Combined Listener:  --------------------------------------------------------------------------');\n        console.warn(`Combined Event-Listener '${emitEvent}' have been removed for better comprehensibility and simplification`);\n        console.warn('Please use separate listener for each event like <v-form-base  @focus=\"handler\" @input=\"handler\" @blur=\"handler\"/>');\n        console.warn('---------------------------------------------------------------------------------------------');\n      }\n    },\n    //\n    // PREPARE ARRAYS DATA & SCHEMA\n    setObjectByPath(object, path, value) {\n      // resolves chained keys (like 'user.address.street') on an object and set the value\n      const pathArray = path.split(pathDelimiter);\n      pathArray.forEach((p, ix) => {\n        if (ix === pathArray.length - 1) this.$set(object, p, value);\n        object = object[p];\n      });\n    },\n    updateArrayFromState(data, schema) {\n      this.flatCombinedArray.forEach(obj => {\n        obj.value = get(data, obj.key, null); // get - lodash\n        obj.schema = get(schema, obj.key, null); // get - lodash\n      });\n    },\n\n    sanitizeShorthandType(key, schema) {\n      // if key in schema is string only, then handle shorthand definition\n      // schema:{ name:'text' }  => schema:{ name: { type:'text', label: 'name' }\n      return isString(schema) ? {\n        type: schema,\n        label: key\n      } : schema;\n    },\n    flattenObjects(dat = {}, sch) {\n      const data = {};\n      const schema = {};\n      // Organize Formular using Schema not Data\n      Object.keys(sch).forEach(key => {\n        // convert string definition of name:'text' into object name:{type:'text'}\n        sch[key] = this.sanitizeShorthandType(key, sch[key]);\n        const bothArray = Array.isArray(dat[key]) && Array.isArray(sch[key]);\n        const datObjectWithoutSchemaType = isPlainObject(dat[key]) && !sch[key].type;\n        const datObjectContainsTypeKey = dat[key] && dat[key].type && sch[key] && sch[key].type;\n        const notInstanceOfFileObject = !(dat[key] instanceof File);\n        if (bothArray || datObjectWithoutSchemaType || datObjectContainsTypeKey && notInstanceOfFileObject) {\n          const {\n            data: flatData,\n            schema: flatSchema\n          } = this.flattenObjects(dat[key], sch[key]);\n          Object.keys(flatData).forEach(ii => {\n            data[key + pathDelimiter + ii] = flatData[ii];\n            schema[key + pathDelimiter + ii] = flatSchema[ii];\n          });\n        } else {\n          data[key] = dat[key];\n          schema[key] = sch[key];\n        }\n      });\n      return {\n        data,\n        schema\n      };\n    },\n    combineObjectsToArray({\n      data,\n      schema\n    }) {\n      const arr = [];\n      Object.keys(schema).forEach(key => {\n        if (!isPlainObject(schema[key])) {\n          console.warn(`Schema '${JSON.stringify(schema)}' of Prop '${key}' must be a string with value of type key:'text' or a plainobject with at least key:{ type:'text'} definition.  Prop '${key}' will be ignored!`);\n          return;\n        }\n        arr.push({\n          key,\n          value: data[key],\n          schema: schema[key]\n        });\n      });\n      return arr;\n    },\n    flattenAndCombineToArray(data, schema) {\n      // flatten nested structure of both objects 'data' & 'schema' ...\n      const flattenedObjects = this.flattenObjects(data, schema);\n      // ... and combine them to an array\n      return this.combineObjectsToArray(flattenedObjects);\n    },\n    autogenerateSchema(value) {\n      // generate a minimal default schema from value\n      let schema = JSON.stringify(value, (key, val) => val === undefined ? null : val);\n      schema = JSON.parse(schema, (key, val) => {\n        if (val === null || val === undefined) return defaultSchemaIfValueIsNullOrUndefined(key);\n        if (typeof val === 'string') return defaultSchemaIfValueIsString(key);\n        if (typeof val === 'number') return defaultSchemaIfValueIsNumber(key);\n        if (typeof val === 'boolean') return defaultSchemaIfValueIsBoolean(key);\n        return val;\n      });\n      // assign root props to avoid manipulating prop: schema\n      Object.keys(schema).forEach(key => this.schema[key] = schema[key]);\n    },\n    tryAutogenerateModelStructure(model, schema) {\n      // generate or complete an empty model based on schema structure\n\n      Object.keys(schema).forEach(key => {\n        // model must be at least an empty Object. It doesn't work with 'null', 'undefined' or any 'primitive value'\n        // Autogeneration from Schema works only if model is an empty Object\n        // if model is NOT an empty Object, no action is applied, otherwise data in model could be changed or modified\n        if (!isEmpty(model[key])) return;\n        const val = schema[key];\n        if (val.type === 'group') {\n          this.$set(model, key, {});\n          this.tryAutogenerateModelStructure(model[key], val.schema);\n        } else if (val.type === 'array') {\n          this.$set(model, key, []);\n          this.tryAutogenerateModelStructure(model[key], val.schema);\n        } else if (val.type === 'list') {\n          this.$set(model, key, []);\n        } else if (isPlainObject(val) && !val.type) {\n          this.$set(model, key, {});\n          this.tryAutogenerateModelStructure(model[key], val);\n        }\n        if (Array.isArray(val) && !val.type) {\n          this.$set(model, key, []);\n          this.tryAutogenerateModelStructure(model[key], val);\n        }\n      });\n    },\n    rebuildArrays(model, schema) {\n      // undefined, null or primitive value for model can't work because you need reference to object for working on\n      if (!model) throw 'Property \\'model\\' is null or undefined. Use \\'<v-form-base :model=\"myModel\" :schema=\"mySchema\" />\\'. myModel must be at least an empty Object.';\n\n      // noise if async loading\n      if (isEmpty(schema) && isEmpty(model)) {\n        console.warn('At least one of the properties \\'model\\' or \\'schema\\' in <v-form-base /> must be at least an empty Object. Ignore this Warning on async loading \\'model\\' or \\'schema\\' ');\n        // return\n      }\n      // generate/complete structure of model\n      this.tryAutogenerateModelStructure(model, schema);\n\n      // no schema defined or empty -> autogenerate basic schema\n      if (isEmpty(schema)) this.autogenerateSchema(model);\n\n      // create flatted working array from schema and value\n      this.flatCombinedArray = this.flattenAndCombineToArray(this.storeStateData, this.storeStateSchema);\n    }\n    //\n  },\n\n  created() {\n    this.rebuildArrays(this.valueIntern, this.schema);\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}