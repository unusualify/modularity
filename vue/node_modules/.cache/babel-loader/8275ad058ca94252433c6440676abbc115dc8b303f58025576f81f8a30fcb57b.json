{"ast":null,"code":"import _objectSpread from \"/var/www/crm_template/packages/oobook/crm-base/vue/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.function.bind.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.array.from.js\";\nimport \"core-js/modules/es.string.iterator.js\";\nimport \"core-js/modules/es.array.find-index.js\";\nimport \"core-js/modules/web.dom-collections.iterator.js\";\nimport \"core-js/modules/web.url.js\";\nimport \"core-js/modules/web.url-search-params.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { MEDIA_LIBRARY } from '@/store/mutations';\nimport qq from 'fine-uploader/lib/dnd';\nimport FineUploaderS3 from 'fine-uploader-wrappers/s3';\nimport FineUploaderAzure from 'fine-uploader-wrappers/azure';\nimport FineUploaderTraditional from 'fine-uploader-wrappers/traditional';\nimport sanitizeFilename from '@/utils/sanitizeFilename.js';\nexport default {\n  name: 'A17Uploader',\n  props: {\n    type: {\n      type: Object,\n      required: true\n    }\n  },\n  data: function data() {\n    return {\n      loadingMedias: []\n    };\n  },\n  computed: {\n    uploaderConfig: function uploaderConfig() {\n      return this.type.uploaderConfig;\n    },\n    uploaderValidation: function uploaderValidation() {\n      var extensions = this.uploaderConfig.allowedExtensions;\n      return {\n        allowedExtensions: extensions,\n        acceptFiles: '.' + extensions.join(', .'),\n        stopOnFirstInvalidFile: false\n      };\n    }\n  },\n  methods: {\n    initUploader: function initUploader() {\n      var _this = this;\n      var buttonEl = this.$refs.uploaderBrowseButton;\n      var sharedConfig = {\n        debug: true,\n        maxConnections: 5,\n        button: buttonEl,\n        retry: {\n          enableAuto: false\n        },\n        callbacks: {\n          onSubmit: this._onSubmitCallback.bind(this),\n          onProgress: this._onProgressCallback.bind(this),\n          onError: this._onErrorCallback.bind(this),\n          onComplete: this._onCompleteCallback.bind(this),\n          onAllComplete: this._onAllCompleteCallback.bind(this),\n          onStatusChange: this._onStatusChangeCallback.bind(this),\n          onTotalProgress: this._onTotalProgressCallback.bind(this)\n        },\n        text: {\n          fileInputTitle: 'Browse...'\n        },\n        messages: {\n          // Todo: need to translate this in uploaderConfig\n          retryFailTooManyItemsError: 'Retry failed - you have reached your file limit.',\n          sizeError: '{file} is too large, maximum file size is {sizeLimit}.',\n          tooManyItemsError: 'Too many items ({netItems}) would be uploaded. Item limit is {itemLimit}.',\n          typeError: '{file} has an invalid extension. Valid extension(s): {extensions}.'\n        }\n      };\n      this._uploader = this.uploaderConfig.endpointType === 's3' ? new FineUploaderS3({\n        options: _objectSpread(_objectSpread({}, sharedConfig), {}, {\n          validation: _objectSpread({}, this.uploaderValidation),\n          objectProperties: {\n            key: function key(id) {\n              return _this.unique_folder_name + '/' + sanitizeFilename(_this._uploader.methods.getName(id));\n            },\n            region: this.uploaderConfig.endpointRegion,\n            bucket: this.uploaderConfig.endpointBucket,\n            acl: this.uploaderConfig.acl\n          },\n          request: {\n            endpoint: this.uploaderConfig.endpoint,\n            accessKey: this.uploaderConfig.accessKey\n          },\n          signature: {\n            endpoint: this.uploaderConfig.signatureEndpoint,\n            version: 4,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          },\n          uploadSuccess: {\n            endpoint: this.uploaderConfig.successEndpoint,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          }\n        })\n      }) : this.uploaderConfig.endpointType === 'azure' ? new FineUploaderAzure({\n        options: _objectSpread(_objectSpread({}, sharedConfig), {}, {\n          validation: _objectSpread({}, this.uploaderValidation),\n          cors: {\n            expected: true,\n            sendCredentials: true\n          },\n          blobProperties: {\n            name: function name(id) {\n              return new Promise(function (resolve) {\n                resolve(_this.unique_folder_name + '/' + sanitizeFilename(_this._uploader.methods.getName(id)));\n              });\n            }\n          },\n          request: {\n            endpoint: this.uploaderConfig.endpoint\n          },\n          signature: {\n            endpoint: this.uploaderConfig.signatureEndpoint,\n            version: 4,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          },\n          uploadSuccess: {\n            endpoint: this.uploaderConfig.successEndpoint,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          }\n        })\n      }) : new FineUploaderTraditional({\n        options: _objectSpread(_objectSpread({}, sharedConfig), {}, {\n          validation: _objectSpread(_objectSpread({}, this.uploaderValidation), {}, {\n            sizeLimit: this.uploaderConfig.filesizeLimit * 1048576 // mb to bytes\n          }),\n\n          request: {\n            endpoint: this.uploaderConfig.endpoint,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          }\n        })\n      });\n    },\n    replaceMedia: function replaceMedia(id) {\n      this.media_to_replace_id = id;\n      var qqinputs = this.$refs.uploaderBrowseButton.querySelectorAll('[name = \"qqfile\"]');\n      qqinputs[Array.from(qqinputs).length - 1].click();\n    },\n    loadingProgress: function loadingProgress(media) {\n      this.$store.commit(MEDIA_LIBRARY.PROGRESS_UPLOAD_MEDIA, media);\n    },\n    loadingFinished: function loadingFinished(loadingMedia, savedMedia) {\n      // add the saved image to the main image list\n      this.$emit('loaded', savedMedia);\n      this.$store.commit(MEDIA_LIBRARY.DONE_UPLOAD_MEDIA, loadingMedia);\n    },\n    loadingError: function loadingError(media) {\n      this.$store.commit(MEDIA_LIBRARY.ERROR_UPLOAD_MEDIA, media);\n    },\n    uploadProgress: function uploadProgress(_uploadProgress) {\n      this.$store.commit(MEDIA_LIBRARY.PROGRESS_UPLOAD, _uploadProgress);\n    },\n    _onCompleteCallback: function _onCompleteCallback(id, name, responseJSON, xhr) {\n      var _this2 = this;\n      var index = this.loadingMedias.findIndex(function (m) {\n        return m.id === _this2._uploader.methods.getUuid(id);\n      });\n      if (responseJSON.success) {\n        this.loadingFinished(this.loadingMedias[index], responseJSON.media);\n      } else {\n        this.loadingError(this.loadingMedias[index]);\n      }\n    },\n    _onAllCompleteCallback: function _onAllCompleteCallback(succeeded, failed) {\n      // reset folder name for next upload session\n      this.unique_folder_name = null;\n      this.uploadProgress(0);\n    },\n    _onSubmitCallback: function _onSubmitCallback(id, name) {\n      var _this3 = this;\n      this.$emit('clear');\n      // each upload session will add upload files with original filenames in a folder named using a uuid\n      this.unique_folder_name = this.unique_folder_name || this.uploaderConfig.endpointRoot + qq.getUniqueId();\n      this._uploader.methods.setParams({\n        unique_folder_name: this.unique_folder_name,\n        media_to_replace_id: this.media_to_replace_id\n      }, id);\n\n      // determine the image dimensions and add it to params sent on upload success\n      var imageUrl = URL.createObjectURL(this._uploader.methods.getFile(id));\n      var img = new Image();\n      img.onload = function () {\n        _this3._uploader.methods.setParams({\n          width: img.width,\n          height: img.height,\n          unique_folder_name: _this3.unique_folder_name,\n          media_to_replace_id: _this3.media_to_replace_id\n        }, id);\n        _this3.media_to_replace_id = null;\n      };\n      img.src = imageUrl;\n      var media = {\n        id: this._uploader.methods.getUuid(id),\n        name: sanitizeFilename(name),\n        progress: 0,\n        error: false,\n        errorMessage: null,\n        isReplacement: !!this.media_to_replace_id,\n        replacementId: this.media_to_replace_id\n      };\n      if (this.type.value === 'file') {\n        this.media_to_replace_id = null;\n      }\n      this.loadingMedias.push(media);\n      this.loadingProgress(media);\n    },\n    _onProgressCallback: function _onProgressCallback(id, name, uploadedBytes, totalBytes) {\n      var _this4 = this;\n      var index = this.loadingMedias.findIndex(function (m) {\n        return m.id === _this4._uploader.methods.getUuid(id);\n      });\n      if (index >= 0) {\n        var media = this.loadingMedias[index];\n        media.progress = uploadedBytes / totalBytes * 100 || 0;\n        media.error = false;\n        this.loadingProgress(media);\n      }\n    },\n    _onErrorCallback: function _onErrorCallback(id, name, errorReason, xhr) {\n      var _this5 = this;\n      var index = id ? this.loadingMedias.findIndex(function (m) {\n        return m.id === _this5._uploader.methods.getUuid(id);\n      }) : -1;\n      if (index >= 0) {\n        this.loadingMedias[index].errorMessage = errorReason;\n        this.loadingError(this.loadingMedias[index]);\n      } else {\n        var media = {\n          id: id ? this._uploader.methods.getUuid(id) : Math.floor(Math.random() * 1000),\n          name: sanitizeFilename(name),\n          progress: 0,\n          error: true,\n          errorMessage: errorReason\n        };\n        this.loadingMedias.push(media);\n        this.loadingProgress(media);\n        this.loadingError(this.loadingMedias[this.loadingMedias.length - 1]);\n      }\n    },\n    _onStatusChangeCallback: function _onStatusChangeCallback(id, oldStatus, newStatus) {\n      if (newStatus === 'retrying upload') {\n        var index = this.loadingMedias.findIndex(function (m) {\n          return m.id === id;\n        });\n        if (index >= 0) {\n          var media = this.loadingMedias[index];\n          media.progress = 0;\n          media.error = false;\n          this.loadingProgress(media);\n        }\n      }\n    },\n    _onTotalProgressCallback: function _onTotalProgressCallback(totalUploadedBytes, totalBytes) {\n      var uploadProgress = Math.floor(totalUploadedBytes / totalBytes * 100);\n      this.uploadProgress(uploadProgress);\n    },\n    _onDropError: function _onDropError(errorCode, errorData) {\n      console.error(errorCode, errorData);\n    },\n    _onProcessingDroppedFilesComplete: function _onProcessingDroppedFilesComplete(files) {\n      this._uploader.methods.addFiles(files);\n    }\n  },\n  watch: {\n    type: function type() {\n      if (this._uploader) {\n        this.initUploader();\n      }\n    }\n  },\n  mounted: function mounted() {\n    // Init uploader\n    this.initUploader();\n\n    // Init dropzone\n    var dropzoneEl = this.$refs.uploaderDropzone;\n    this._qqDropzone && this._qqDropzone.dispose();\n    this._qqDropzone = new qq.DragAndDrop({\n      dropZoneElements: [dropzoneEl],\n      allowMultipleItems: true,\n      callbacks: {\n        dropError: this._onDropError.bind(this),\n        processingDroppedFilesComplete: this._onProcessingDroppedFilesComplete.bind(this)\n      }\n    });\n  },\n  beforeDestroy: function beforeDestroy() {\n    this._qqDropzone && this._qqDropzone.dispose();\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}