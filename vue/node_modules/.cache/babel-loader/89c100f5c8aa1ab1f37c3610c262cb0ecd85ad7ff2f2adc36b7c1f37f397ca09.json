{"ast":null,"code":"import { MEDIA_LIBRARY } from '@/store/mutations';\nimport qq from 'fine-uploader/lib/dnd';\nimport FineUploaderS3 from 'fine-uploader-wrappers/s3';\nimport FineUploaderAzure from 'fine-uploader-wrappers/azure';\nimport FineUploaderTraditional from 'fine-uploader-wrappers/traditional';\nimport sanitizeFilename from '@/utils/sanitizeFilename.js';\nexport default {\n  name: 'A17Uploader',\n  props: {\n    type: {\n      type: Object,\n      required: true\n    }\n  },\n  data: function () {\n    return {\n      loadingMedias: []\n    };\n  },\n  computed: {\n    uploaderConfig: function () {\n      return this.type.uploaderConfig;\n    },\n    uploaderValidation: function () {\n      const extensions = this.uploaderConfig.allowedExtensions;\n      return {\n        allowedExtensions: extensions,\n        acceptFiles: '.' + extensions.join(', .'),\n        stopOnFirstInvalidFile: false\n      };\n    }\n  },\n  methods: {\n    initUploader: function () {\n      const buttonEl = this.$refs.uploaderBrowseButton;\n      const sharedConfig = {\n        debug: true,\n        maxConnections: 5,\n        button: buttonEl,\n        retry: {\n          enableAuto: false\n        },\n        callbacks: {\n          onSubmit: this._onSubmitCallback.bind(this),\n          onProgress: this._onProgressCallback.bind(this),\n          onError: this._onErrorCallback.bind(this),\n          onComplete: this._onCompleteCallback.bind(this),\n          onAllComplete: this._onAllCompleteCallback.bind(this),\n          onStatusChange: this._onStatusChangeCallback.bind(this),\n          onTotalProgress: this._onTotalProgressCallback.bind(this)\n        },\n        text: {\n          fileInputTitle: 'Browse...'\n        },\n        messages: {\n          // Todo: need to translate this in uploaderConfig\n          retryFailTooManyItemsError: 'Retry failed - you have reached your file limit.',\n          sizeError: '{file} is too large, maximum file size is {sizeLimit}.',\n          tooManyItemsError: 'Too many items ({netItems}) would be uploaded. Item limit is {itemLimit}.',\n          typeError: '{file} has an invalid extension. Valid extension(s): {extensions}.'\n        }\n      };\n      this._uploader = this.uploaderConfig.endpointType === 's3' ? new FineUploaderS3({\n        options: {\n          ...sharedConfig,\n          validation: {\n            ...this.uploaderValidation\n          },\n          objectProperties: {\n            key: id => {\n              return this.unique_folder_name + '/' + sanitizeFilename(this._uploader.methods.getName(id));\n            },\n            region: this.uploaderConfig.endpointRegion,\n            bucket: this.uploaderConfig.endpointBucket,\n            acl: this.uploaderConfig.acl\n          },\n          request: {\n            endpoint: this.uploaderConfig.endpoint,\n            accessKey: this.uploaderConfig.accessKey\n          },\n          signature: {\n            endpoint: this.uploaderConfig.signatureEndpoint,\n            version: 4,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          },\n          uploadSuccess: {\n            endpoint: this.uploaderConfig.successEndpoint,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          }\n        }\n      }) : this.uploaderConfig.endpointType === 'azure' ? new FineUploaderAzure({\n        options: {\n          ...sharedConfig,\n          validation: {\n            ...this.uploaderValidation\n          },\n          cors: {\n            expected: true,\n            sendCredentials: true\n          },\n          blobProperties: {\n            name: id => {\n              return new Promise(resolve => {\n                resolve(this.unique_folder_name + '/' + sanitizeFilename(this._uploader.methods.getName(id)));\n              });\n            }\n          },\n          request: {\n            endpoint: this.uploaderConfig.endpoint\n          },\n          signature: {\n            endpoint: this.uploaderConfig.signatureEndpoint,\n            version: 4,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          },\n          uploadSuccess: {\n            endpoint: this.uploaderConfig.successEndpoint,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          }\n        }\n      }) : new FineUploaderTraditional({\n        options: {\n          ...sharedConfig,\n          validation: {\n            ...this.uploaderValidation,\n            sizeLimit: this.uploaderConfig.filesizeLimit * 1048576 // mb to bytes\n          },\n\n          request: {\n            endpoint: this.uploaderConfig.endpoint,\n            customHeaders: {\n              'X-CSRF-TOKEN': this.uploaderConfig.csrfToken\n            }\n          }\n        }\n      });\n    },\n    replaceMedia: function (id) {\n      this.media_to_replace_id = id;\n      const qqinputs = this.$refs.uploaderBrowseButton.querySelectorAll('[name = \"qqfile\"]');\n      qqinputs[Array.from(qqinputs).length - 1].click();\n    },\n    loadingProgress: function (media) {\n      this.$store.commit(MEDIA_LIBRARY.PROGRESS_UPLOAD_MEDIA, media);\n    },\n    loadingFinished: function (loadingMedia, savedMedia) {\n      // add the saved image to the main image list\n      this.$emit('loaded', savedMedia);\n      this.$store.commit(MEDIA_LIBRARY.DONE_UPLOAD_MEDIA, loadingMedia);\n    },\n    loadingError: function (media) {\n      this.$store.commit(MEDIA_LIBRARY.ERROR_UPLOAD_MEDIA, media);\n    },\n    uploadProgress: function (uploadProgress) {\n      this.$store.commit(MEDIA_LIBRARY.PROGRESS_UPLOAD, uploadProgress);\n    },\n    _onCompleteCallback(id, name, responseJSON, xhr) {\n      const index = this.loadingMedias.findIndex(m => m.id === this._uploader.methods.getUuid(id));\n      if (responseJSON.success) {\n        this.loadingFinished(this.loadingMedias[index], responseJSON.media);\n      } else {\n        this.loadingError(this.loadingMedias[index]);\n      }\n    },\n    _onAllCompleteCallback(succeeded, failed) {\n      // reset folder name for next upload session\n      this.unique_folder_name = null;\n      this.uploadProgress(0);\n    },\n    _onSubmitCallback(id, name) {\n      this.$emit('clear');\n      // each upload session will add upload files with original filenames in a folder named using a uuid\n      this.unique_folder_name = this.unique_folder_name || this.uploaderConfig.endpointRoot + qq.getUniqueId();\n      this._uploader.methods.setParams({\n        unique_folder_name: this.unique_folder_name,\n        media_to_replace_id: this.media_to_replace_id\n      }, id);\n\n      // determine the image dimensions and add it to params sent on upload success\n      const imageUrl = URL.createObjectURL(this._uploader.methods.getFile(id));\n      const img = new Image();\n      img.onload = () => {\n        this._uploader.methods.setParams({\n          width: img.width,\n          height: img.height,\n          unique_folder_name: this.unique_folder_name,\n          media_to_replace_id: this.media_to_replace_id\n        }, id);\n        this.media_to_replace_id = null;\n      };\n      img.src = imageUrl;\n      const media = {\n        id: this._uploader.methods.getUuid(id),\n        name: sanitizeFilename(name),\n        progress: 0,\n        error: false,\n        errorMessage: null,\n        isReplacement: !!this.media_to_replace_id,\n        replacementId: this.media_to_replace_id\n      };\n      if (this.type.value === 'file') {\n        this.media_to_replace_id = null;\n      }\n      this.loadingMedias.push(media);\n      this.loadingProgress(media);\n    },\n    _onProgressCallback(id, name, uploadedBytes, totalBytes) {\n      const index = this.loadingMedias.findIndex(m => m.id === this._uploader.methods.getUuid(id));\n      if (index >= 0) {\n        const media = this.loadingMedias[index];\n        media.progress = uploadedBytes / totalBytes * 100 || 0;\n        media.error = false;\n        this.loadingProgress(media);\n      }\n    },\n    _onErrorCallback(id, name, errorReason, xhr) {\n      const index = id ? this.loadingMedias.findIndex(m => m.id === this._uploader.methods.getUuid(id)) : -1;\n      if (index >= 0) {\n        this.loadingMedias[index].errorMessage = errorReason;\n        this.loadingError(this.loadingMedias[index]);\n      } else {\n        const media = {\n          id: id ? this._uploader.methods.getUuid(id) : Math.floor(Math.random() * 1000),\n          name: sanitizeFilename(name),\n          progress: 0,\n          error: true,\n          errorMessage: errorReason\n        };\n        this.loadingMedias.push(media);\n        this.loadingProgress(media);\n        this.loadingError(this.loadingMedias[this.loadingMedias.length - 1]);\n      }\n    },\n    _onStatusChangeCallback(id, oldStatus, newStatus) {\n      if (newStatus === 'retrying upload') {\n        const index = this.loadingMedias.findIndex(function (m) {\n          return m.id === id;\n        });\n        if (index >= 0) {\n          const media = this.loadingMedias[index];\n          media.progress = 0;\n          media.error = false;\n          this.loadingProgress(media);\n        }\n      }\n    },\n    _onTotalProgressCallback(totalUploadedBytes, totalBytes) {\n      const uploadProgress = Math.floor(totalUploadedBytes / totalBytes * 100);\n      this.uploadProgress(uploadProgress);\n    },\n    _onDropError(errorCode, errorData) {\n      console.error(errorCode, errorData);\n    },\n    _onProcessingDroppedFilesComplete(files) {\n      this._uploader.methods.addFiles(files);\n    }\n  },\n  watch: {\n    type: function () {\n      if (this._uploader) {\n        this.initUploader();\n      }\n    }\n  },\n  mounted() {\n    // Init uploader\n    this.initUploader();\n\n    // Init dropzone\n    const dropzoneEl = this.$refs.uploaderDropzone;\n    this._qqDropzone && this._qqDropzone.dispose();\n    this._qqDropzone = new qq.DragAndDrop({\n      dropZoneElements: [dropzoneEl],\n      allowMultipleItems: true,\n      callbacks: {\n        dropError: this._onDropError.bind(this),\n        processingDroppedFilesComplete: this._onProcessingDroppedFilesComplete.bind(this)\n      }\n    });\n  },\n  beforeDestroy() {\n    this._qqDropzone && this._qqDropzone.dispose();\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}