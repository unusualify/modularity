"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var vls = require("vls");
var html = require("vscode-html-languageservice");
var vscode_uri_1 = require("vscode-uri");
var fs = require("fs");
var path = require("path");
var userSnippetDir_1 = require("./userSnippetDir");
module.exports = function () {
    var _a;
    var htmlDocuments = new WeakMap();
    var uriToPackageJsonPath = new Map();
    var htmlDataPrividers = new Map();
    var htmlLs = html.getLanguageService();
    // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/html-language-features/server/src/htmlServer.ts#L183
    var htmlTriggerCharacters = ['.', ':', '<', '"', '=', '/', /* vue event shorthand */ '@'];
    var snippetManager = new vls.SnippetManager((_a = getSnippetsPath()) !== null && _a !== void 0 ? _a : '' /* TODO: find snippets folder from document path */, (0, userSnippetDir_1.getGlobalSnippetDir)(false));
    var scaffoldSnippetSources = {
        workspace: '💼',
        user: '🗒️',
        vetur: '✌'
    };
    return {
        complete: {
            triggerCharacters: __spreadArray([], htmlTriggerCharacters, true),
            isAdditional: true,
            on: function (document, position, context) {
                var result;
                if (!context.triggerCharacter || htmlTriggerCharacters.includes(context.triggerCharacter)) {
                    htmlWorker(document, function (htmlDocument) {
                        result = htmlLs.doComplete(document, position, htmlDocument);
                    });
                }
                if (!context.triggerCharacter) {
                    vueWorker(document, function () {
                        var items = snippetManager.completeSnippets(scaffoldSnippetSources);
                        if (items.length) {
                            result = {
                                isIncomplete: false,
                                items: items
                            };
                        }
                    });
                }
                return result;
            }
        },
        doHover: function (document, position) {
            return htmlWorker(document, function (htmlDocument) {
                return htmlLs.doHover(document, position, htmlDocument);
            });
        },
        findDocumentSemanticTokens: function (document, range) {
            return htmlWorker(document, function (htmlDocument) {
                var packageJsonPath = getPackageJsonPath(document);
                if (!packageJsonPath)
                    return;
                var dtmlDataProviders = getHtmlDataProviders(packageJsonPath);
                var components = new Set(dtmlDataProviders.map(function (provider) { return provider.getId() === 'html5' ? [] : provider.provideTags().map(function (tag) { return tag.name; }); }).flat());
                var offsetRange = {
                    start: document.offsetAt(range.start),
                    end: document.offsetAt(range.end)
                };
                var scanner = htmlLs.createScanner(document.getText());
                var result = [];
                var token = scanner.scan();
                while (token !== html.TokenType.EOS) {
                    var tokenOffset = scanner.getTokenOffset();
                    // TODO: fix source map perf and break in while condition
                    if (tokenOffset > offsetRange.end)
                        break;
                    if (tokenOffset >= offsetRange.start && (token === html.TokenType.StartTag || token === html.TokenType.EndTag)) {
                        var tokenText = scanner.getTokenText();
                        if (components.has(tokenText) || tokenText.indexOf('.') >= 0) {
                            var tokenLength = scanner.getTokenLength();
                            var tokenPosition = document.positionAt(tokenOffset);
                            if (components.has(tokenText)) {
                                result.push([tokenPosition.line, tokenPosition.character, tokenLength, 10 /* 10: function, 12: component */, 0]);
                            }
                        }
                    }
                    token = scanner.scan();
                }
                return result;
            });
        }
    };
    function htmlWorker(document, callback) {
        var htmlDocument = getHtmlDocument(document);
        if (!htmlDocument)
            return;
        var packageJsonPath = getPackageJsonPath(document);
        if (!packageJsonPath)
            return;
        htmlLs.setDataProviders(false, getHtmlDataProviders(packageJsonPath));
        return callback(htmlDocument);
    }
    function vueWorker(document, callback) {
        if (document.languageId === 'vue') {
            return callback();
        }
    }
    function getPackageJsonPath(document) {
        var packageJsonPath = uriToPackageJsonPath.get(document.uri);
        if (!packageJsonPath) {
            var uri = vscode_uri_1.URI.parse(document.uri);
            var fsPath = uri.fsPath;
            var lastDirname = fsPath;
            while (true) {
                var dirname = path.dirname(lastDirname);
                if (dirname === lastDirname) {
                    break;
                }
                if (fs.existsSync(dirname + '/package.json')) {
                    packageJsonPath = dirname + '/package.json';
                    break;
                }
                lastDirname = dirname;
            }
            uriToPackageJsonPath.set(document.uri, packageJsonPath);
        }
        return packageJsonPath;
    }
    function getSnippetsPath() {
        var fsPath = __filename;
        var lastDirname = fsPath;
        var snippetsPath;
        while (true) {
            var dirname = path.dirname(lastDirname);
            if (dirname === lastDirname) {
                break;
            }
            if (fs.existsSync(dirname + '/.vscode/vetur/snippets')) {
                snippetsPath = dirname + '/.vscode/vetur/snippets';
                break;
            }
            lastDirname = dirname;
        }
        return snippetsPath;
    }
    function getHtmlDataProviders(packageJsonPath) {
        var dataProviders = htmlDataPrividers.get(packageJsonPath);
        if (!dataProviders) {
            var tagProviderSettings = vls.getTagProviderSettings(packageJsonPath);
            var enabledTagProviders = vls.getEnabledTagProviders(tagProviderSettings);
            dataProviders = enabledTagProviders.map(function (provider) {
                var htmlProvider = {
                    getId: provider.getId,
                    isApplicable: function () {
                        return true;
                    },
                    provideTags: function () {
                        var tags = [];
                        provider.collectTags(function (tag, documentation) {
                            tags.push({
                                name: tag,
                                description: documentation,
                                attributes: []
                            });
                        });
                        return tags;
                    },
                    provideAttributes: function (tag) {
                        var attributes = [];
                        provider.collectAttributes(tag, function (attribute, type, documentation) {
                            if (attribute.startsWith('v-') || attribute.startsWith('@')) {
                                attributes.push({
                                    name: attribute,
                                    valueSet: type,
                                    description: documentation
                                });
                            }
                            else {
                                attributes.push({
                                    name: 'v-bind:' + attribute,
                                    valueSet: type,
                                    description: documentation
                                });
                                attributes.push({
                                    name: ':' + attribute,
                                    valueSet: type,
                                    description: documentation
                                });
                                attributes.push({
                                    name: attribute,
                                    valueSet: type,
                                    description: documentation
                                });
                            }
                        });
                        return attributes;
                    },
                    provideValues: function (tag, attribute) {
                        var values = [];
                        provider.collectValues(tag, attribute, function (value) {
                            values.push({
                                name: value
                            });
                        });
                        return values;
                    }
                };
                return htmlProvider;
            });
            htmlDataPrividers.set(packageJsonPath, dataProviders);
        }
        return dataProviders;
    }
    function getHtmlDocument(document) {
        if (document.languageId !== 'html')
            return;
        var htmlDocument = htmlDocuments.get(document);
        if (!htmlDocument) {
            htmlDocument = htmlLs.parseHTMLDocument(document);
            htmlDocuments.set(document, htmlDocument);
        }
        return htmlDocument;
    }
};
